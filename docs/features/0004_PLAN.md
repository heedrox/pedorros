# PLAN TÉCNICO - Cálculo Automático de Roles y Sonidos

## Descripción de la Funcionalidad

Implementar un listener de Firebase que detecte cambios en `/pedorros-game/{codigo-juego}` y, cuando el estado sea "START", calcule automáticamente:

1. **Distribución de roles**: Asignar peditos, pedorro y neutrales según la tabla del PRODUCT_BRIEF
2. **Sonidos asignados**: Generar diccionario `nextSounds` con sonidos para cada jugador
3. **Persistencia en BD**: Guardar los resultados en Firebase Database

## Archivos y Funciones a Modificar

### Archivos Existentes a Modificar

#### `web/lib.js`
- **Nueva función**: `calculateGameRoles(totalPlayers)` - Calcula distribución de roles
- **Nueva función**: `generateNextSounds(roles, totalPlayers)` - Genera diccionario de sonidos
- **Nueva función**: `shuffleArray(array)` - Función de utilidad para mezclar arrays

#### `web/firebase-database.js`
- **Nueva función**: `setupGameStateListener(gameCode, callback)` - Configura listener de Firebase
- **Nueva función**: `updateGameRoles(gameCode, roles, nextSounds)` - Actualiza roles en BD
- **Modificar**: `getResetGameState()` - Añadir campos `peditos` y `pedorro`

#### `web/script.js`
- **Modificar**: `initializeApp()` - Configurar listener cuando se inicializa la app
- **Nueva función**: `handleGameStateChange(gameData)` - Maneja cambios en el estado del juego

### Archivos a Crear

Ninguno - toda la funcionalidad se integra en archivos existentes.

## Algoritmo de Implementación

### Fase 1: Lógica de Cálculo de Roles (lib.js)

#### Función `calculateGameRoles(totalPlayers)`
1. **Validar entrada**: Verificar que `totalPlayers` esté entre 4-16
2. **Obtener distribución**: Usar tabla del PRODUCT_BRIEF para determinar cantidad de peditos
3. **Generar array base**: Crear array `[1, 2, 3, ..., totalPlayers]`
4. **Shuffle del array**: Mezclar aleatoriamente el array base
5. **Extraer roles**:
   - Tomar primeros `cantidadPeditos` elementos → `peditos`
   - Tomar siguiente elemento → `pedorro`
   - Resto → `neutrales` (no se almacenan, solo para lógica)
6. **Retornar objeto**: `{ peditos: [...], pedorro: number }`

#### Función `generateNextSounds(roles, totalPlayers)`
1. **Crear diccionario base**: `{ 1: null, 2: null, ..., totalPlayers: null }`
2. **Asignar sonidos peditos**: Todos los peditos reciben el mismo número (1-5)
3. **Asignar sonido pedorro**: Número único (1-5, puede coincidir con peditos)
4. **Retornar diccionario**: `nextSounds` completo

#### Función `shuffleArray(array)`
1. **Clonar array**: Evitar mutación del array original
2. **Algoritmo Fisher-Yates**: Mezclar elementos aleatoriamente
3. **Retornar array mezclado**: Nuevo array inmutable

### Fase 2: Integración con Firebase (firebase-database.js)

#### Función `setupGameStateListener(gameCode, callback)`
1. **Crear referencia**: `ref(database, 'pedorros-game/' + gameCode)`
2. **Configurar listener**: `onValue(ref, callback)`
3. **Manejar desconexión**: Retornar función de cleanup

#### Función `updateGameRoles(gameCode, roles, nextSounds)`
1. **Validar datos**: Verificar estructura de roles y nextSounds
2. **Actualizar BD**: Usar `update()` para modificar solo campos específicos
3. **Manejar errores**: Retornar Promise con resultado de la operación

#### Modificación de `getResetGameState()`
1. **Añadir campo `peditos`**: Array vacío por defecto
2. **Añadir campo `pedorro`**: `null` por defecto
3. **Eliminar campo `pedorroSound`**: Ya no necesario con nueva estructura
4. **Mantener compatibilidad**: No romper funcionalidad existente

### Fase 3: Integración en la UI (script.js)

#### Función `handleGameStateChange(gameData)`
1. **Verificar jugador**: Solo procesar si es el jugador 1 (director del juego)
2. **Verificar estado**: Solo procesar si `state === "START"`
3. **Verificar cambio de código**: Detectar si el código del juego cambió
4. **Calcular roles**: Llamar a `calculateGameRoles()`
5. **Generar sonidos**: Llamar a `generateNextSounds()`
6. **Actualizar BD**: Llamar a `updateGameRoles()`

#### Modificación de `initializeApp()`
1. **Verificar jugador**: Solo configurar listener si es el jugador 1
2. **Configurar listener**: Llamar a `setupGameStateListener()` solo para jugador 1
3. **Manejar cleanup**: Guardar referencia para limpieza posterior
4. **Integrar con estado existente**: No interferir con funcionalidad actual

## Detalles de Implementación

### Estructura de Datos en Firebase

```json
{
  "pedorros-game": {
    "galerna": {
      "state": "START",
      "numRound": 1,
      "peditos": [2, 4],
      "pedorro": 1,
      "nextSounds": {
        "1": 3,
        "2": 2,
        "3": null,
        "4": 2,
        "5": null
      },
      "ranking": {},
      "lastResult": null
    }
  }
}
```

### Lógica de Detección de Cambios

- **Listener activo**: Se configura una vez al inicializar la app
- **Detección de cambios**: Firebase notifica automáticamente cambios en el documento
- **Filtrado por jugador**: Solo el jugador 1 procesa los cambios (director del juego)
- **Filtrado por estado**: Solo procesar cambios cuando `state === "START"`
- **Prevención de loops**: Verificar que los datos no sean los mismos que ya se calcularon

### Manejo de Errores

- **Validación de entrada**: Verificar rangos válidos (4-16 jugadores)
- **Fallback de roles**: Si falla el cálculo, mantener estado anterior
- **Logging de errores**: Registrar errores para debugging
- **Recuperación**: Intentar recalcular en siguiente cambio de estado

## Consideraciones Técnicas

### Inmutabilidad
- **Funciones puras**: Todas las funciones de cálculo retornan nuevos objetos
- **Sin side effects**: No modificar arrays o objetos de entrada
- **Spread operator**: Usar para crear copias inmutables

### Performance
- **Listener único**: Un solo listener por sesión de juego (solo jugador 1)
- **Debouncing**: Evitar múltiples cálculos en cambios rápidos
- **Cleanup**: Limpiar listener al cerrar la app
- **Filtrado eficiente**: Solo jugador 1 procesa cambios, resto ignora

### Testing
- **Tests unitarios**: Para todas las funciones de cálculo
- **Tests de integración**: Para la lógica de Firebase
- **Mocks**: Simular Firebase para tests aislados

## Dependencias

- **Firebase SDK**: Ya configurado en el proyecto
- **Funciones existentes**: Reutilizar lógica de validación y estado
- **Arquitectura actual**: Mantener separación lib.js vs script.js

## Riesgos y Mitigaciones

### Riesgo: Cálculo duplicado
- **Mitigación**: Verificar que los datos no sean idénticos antes de recalcular

### Riesgo: Pérdida de sincronización
- **Mitigación**: Usar transacciones de Firebase para actualizaciones atómicas

### Riesgo: Performance en cambios frecuentes
- **Mitigación**: Implementar debouncing y filtrado por estado

### Riesgo: Múltiples jugadores ejecutando cálculo
- **Mitigación**: Restricción estricta - solo jugador 1 puede ejecutar el listener

## Criterios de Completado

- [ ] Función `calculateGameRoles()` implementada y testeada
- [ ] Función `generateNextSounds()` implementada y testeada
- [ ] Listener de Firebase configurado y funcionando
- [ ] Roles y sonidos se calculan automáticamente al cambiar código
- [ ] Datos se persisten correctamente en Firebase
- [ ] Tests unitarios pasando
- [ ] No regresiones en funcionalidad existente
