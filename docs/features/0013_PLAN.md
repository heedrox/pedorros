# PLAN TÉCNICO - Integración del Sistema de Puntuación en RANKING

## Descripción de la Funcionalidad

El usuario quiere integrar el sistema de puntuación de ronda en la pantalla de RANKING. Cuando el jugador 1 detecte que todos han enviado acusaciones y cambie el estado a RANKING, debe calcular la puntuación de la ronda usando `calculateRoundScore`, actualizar el ranking global en Firebase, y mostrar en pantalla el ranking con las puntuaciones totales y los puntos de la ronda actual.

**Prompt del usuario**: "Quiero mostrar en RANKING un ranking global. El ranking será un objeto en el documento de la BD (/pedorros-game/{codigojuego}) llamado 'ranking' que tendrá la puntuación para cada jugador: { 1: x, 2: x, 3: x, ... }. Cuando el jugador 1 recibe todas las acusaciones y se cambia a state = RANKING, antes de cambiar a state = RANKING (en la misma operacion si es posible) va a calcular la puntuacion y va a crear un objeto : lastRoundScore que será la puntuación de la ronda y el resultado a la llamdaa @calculateRoundScore . Luego actualiza ranking y a cada jugador suma su puntuación anterior con la puntuación de la raonda actual. Si no había puntuación anteiror (porque el objeto no existe) entonces la puntuación anterior es 0. CUando se compruebe el cambio de state a RANKING, entonces se recoge ese objeto lastRoundScore, y el ranking total, y se pinta en pantlla en vez de las letras grandes 'RANKING'. Para pintar en pantalla, mostraremos: Posición - Jugador - Puntuación 1 - Jug. 2 - 12 (+5) 2 - Jug. 1 - 8 (+0) 3 - Jug. 4 - 7 (+1) 4 - Jug. 3 - 6 (+2) 5 - Jug. 5 - 5 (+1) El primer numero es la posicion. Luego el jugador como 'Jug. X', siendo X el numero de jugador. La puntuacion total y entre paréntesis (y con letra más pequeña o un color más claro o algo para que sea dierente a la puntuacion total) cuantos puntos nuevos ha sacado en la ronda. COn un + para que quede claro que es lo que ha sumado en esta última ronda)."

## Archivos y Funciones que Deben Cambiarse

### 1. `web/script.js`
- **Función existente**: Modificar `updateAccusationsCounter()` para calcular puntuación antes de cambiar a RANKING
- **Función existente**: Modificar `renderRankingScreen()` para mostrar ranking en lugar de texto "RANKING"
- **Nueva función**: `calculateAndUpdateRanking(acusationsData, gameState)` - Calcula puntuación y actualiza ranking
- **Nueva función**: `renderRankingTable(ranking, lastRoundScore)` - Renderiza tabla de ranking
- **Función existente**: Modificar `cleanupAccusationsTracking()` para limpiar datos de ranking

### 2. `web/firebase-database.js`
- **Nueva función**: `updateGameRanking(gameCode, ranking, lastRoundScore)` - Actualiza ranking y lastRoundScore en Firebase
- **Función existente**: Modificar `updateGameState()` para incluir ranking en la misma operación

### 3. `web/index.html`
- **Modificar pantalla ranking**: Cambiar texto "RANKING" por contenedor para tabla de ranking
- **Nuevos elementos**: Contenedor para tabla de ranking con estructura para posiciones

### 4. `web/styles.css`
- **Nuevos estilos**: Para tabla de ranking, posiciones, puntuaciones totales y puntos de ronda
- **Estilos diferenciados**: Para puntos de ronda (más pequeños/claros que puntuación total)

## Algoritmo de Integración de Puntuación

### Función `updateAccusationsCounter()` Modificada

1. **Input**: `accusationsData` (datos de acusaciones desde Firebase)
2. **Verificar completitud**: Si `progress.totalSent === progress.totalExpected`
3. **Calcular puntuación**: Llamar a `calculateAndUpdateRanking(acusationsData, gameState)`
4. **Cambiar estado**: Solo después de actualizar ranking, cambiar a 'RANKING'
5. **Re-renderizar**: Llamar a `renderScreen(gameState)`

### Función `calculateAndUpdateRanking()`

1. **Input**: `acusationsData`, `gameState`
2. **Obtener roles**: Llamar a `getGameRoles()` para obtener `peditos` y `pedorro`
3. **Calcular puntuación**: Llamar a `calculateRoundScore(acusationsData, peditos, pedorro)`
4. **Obtener ranking actual**: Leer campo `ranking` desde Firebase (o usar `{}` si no existe)
5. **Actualizar puntuaciones**: Para cada jugador, sumar puntos anteriores + puntos de ronda
6. **Guardar en Firebase**: Llamar a `updateGameRanking()` con ranking actualizado y `lastRoundScore`

### Función `renderRankingScreen()` Modificada

1. **Input**: `gameState` (estado actual del juego)
2. **Obtener datos**: Leer `ranking` y `lastRoundScore` desde Firebase
3. **Renderizar tabla**: Llamar a `renderRankingTable(ranking, lastRoundScore)`
4. **Limpiar tracking**: Llamar a `cleanupAccusationsTracking()`

### Función `renderRankingTable()`

1. **Input**: `ranking` (puntuaciones totales), `lastRoundScore` (puntos de ronda)
2. **Ordenar jugadores**: Ordenar por puntuación total descendente
3. **Generar HTML**: Crear tabla con formato "Posición - Jugador - Puntuación (+PuntosRonda)"
4. **Insertar en DOM**: Reemplazar contenido del contenedor de ranking

## Estructura de Datos en Firebase

### Documento del Juego
```
/pedorros-game/{codigojuego}/
├── state: "RANKING"
├── numRound: 3
├── ranking: {
│   1: 15,  // Jugador 1: 15 puntos totales
│   2: 23,  // Jugador 2: 23 puntos totales
│   3: 8,   // Jugador 3: 8 puntos totales
│   4: 12   // Jugador 4: 12 puntos totales
│ }
├── lastRoundScore: {
│   1: 2,   // Jugador 1: +2 puntos en esta ronda
│   2: 5,   // Jugador 2: +5 puntos en esta ronda
│   3: 1,   // Jugador 3: +1 punto en esta ronda
│   4: 3    // Jugador 4: +3 puntos en esta ronda
│ }
└── ... (otros campos existentes)
```

## Fases de Implementación

### Fase 1: Modificación de updateAccusationsCounter
- Modificar `updateAccusationsCounter()` para calcular puntuación antes de cambiar estado
- Implementar `calculateAndUpdateRanking()` con lógica de cálculo y actualización
- Integrar con `updateGameState()` para incluir ranking en la misma operación

### Fase 2: Funciones de Firebase para Ranking
- Implementar `updateGameRanking()` para actualizar ranking y lastRoundScore
- Modificar `updateGameState()` para manejar campos adicionales
- Verificar que la operación sea atómica (ranking y estado en la misma transacción)

### Fase 3: Renderizado de Ranking
- Modificar `renderRankingScreen()` para obtener datos de ranking
- Implementar `renderRankingTable()` con formato especificado
- Crear estilos CSS para diferenciar puntuación total vs puntos de ronda

### Fase 4: Integración y Testing
- Verificar que el cálculo se ejecute correctamente antes del cambio de estado
- Probar que el ranking se actualice correctamente en Firebase
- Validar que la pantalla muestre el ranking ordenado correctamente

## Consideraciones Técnicas

### Inmutabilidad
- **Funciones puras**: Todas las funciones de cálculo retornan nuevos objetos
- **Sin side effects**: No modificar estado global directamente
- **Spread operator**: Usar para crear copias inmutables del estado

### Seguridad
- **Validación de jugador**: Solo el jugador 1 puede calcular puntuación y cambiar estado
- **Verificación de completitud**: Confirmar que realmente todos han enviado acusaciones
- **Manejo de errores**: Capturar y manejar errores en el cálculo y actualización

### Performance
- **Operación atómica**: Actualizar ranking y estado en la misma transacción Firebase
- **Listener único**: Mantener el listener de acusaciones activo hasta la transición
- **Cleanup automático**: Limpiar listeners cuando se cambie de pantalla

### UX
- **Transición automática**: El usuario no necesita hacer nada manual
- **Feedback visual**: Mostrar claramente el ranking con puntuaciones
- **Consistencia**: Mantener el mismo estilo visual que otras pantallas

## Casos de Prueba

### Caso 1: Primera Ronda (ranking vacío)
- **Input**: ranking = {}, lastRoundScore = {1: 5, 2: 3, 3: 7, 4: 2}
- **Expected**: ranking = {1: 5, 2: 3, 3: 7, 4: 2}

### Caso 2: Rondas Subsecuentes
- **Input**: ranking = {1: 5, 2: 3, 3: 7, 4: 2}, lastRoundScore = {1: 2, 2: 5, 3: 1, 4: 3}
- **Expected**: ranking = {1: 7, 2: 8, 3: 8, 4: 5}

### Caso 3: Jugadores Faltantes
- **Input**: ranking = {1: 10, 3: 15}, lastRoundScore = {1: 3, 2: 5, 3: 2, 4: 1}
- **Expected**: ranking = {1: 13, 2: 5, 3: 17, 4: 1}

### Caso 4: Ordenamiento Correcto
- **Input**: ranking = {1: 8, 2: 12, 3: 5, 4: 15}
- **Expected**: Orden en pantalla: 4º Jug. 4 (15), 2º Jug. 2 (12), 1º Jug. 1 (8), 3º Jug. 3 (5)
