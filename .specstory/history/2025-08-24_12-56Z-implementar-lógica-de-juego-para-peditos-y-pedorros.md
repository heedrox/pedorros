<!-- Generated by SpecStory -->

# Implementar lógica de juego para peditos y pedorros (2025-08-24 12:56Z)

_**User**_

@plan-feature.md 

@read-readme-before-implementing-new-features.mdc 
Ahora quiero implementar que cuando el jugador haga listener de /pedorros-game/{codigo-juego}, y si el codigo-juego cambia, y el state = "START", entonces calcule:

- En base a la table que tienes en @PRODUCT_BRIEF.md sobre cantidad de peditos y pedorros y nada
- Meta en la BD, en el doc "codigo-juego" en el campo "peditos" un array de quienes seran los peditos, al azar. Tiene que ser un array de "cantidad de peditos" y todos distintos.
- Meta en la BD, en el doc "codigo-juego", en el campo "pedorro" un elemento de quien es el pedorro. Tiene que ser un numero, y no puede coincidir con los peditos".
    SUGERENCIA:  Una forma de hacer las dos funcionalidades anteriores es coger un array desde el 1 hasta num jugadores, hacer un shuffle, y coger "cantidad de peditos" primero, y esos son los peditos, coger otro elemento, ese es el pedorro, y el resto son "nada".
- Meta en la BD, en el doc "codigo-juego", en el campo "nextSounds", un diccionario con { 1: 1, 2: 1, 3: 1, .. }, siendo los keys del objeto el jugaodr (por tanto ira desde 1 hasta numjugadores) y el  valor el numero de sonido. El numero de sonido será: "null" si eres "nada". Para peditos será otro numero del 1 al 5 no null (el mismo para todos) y para pedorro será otro numero no null (puede ser el mismo de peditos o puede ser otro).

---

_**Assistant**_

Voy a leer el README y PRODUCT_BRIEF para entender mejor el contexto del proyecto antes de crear el plan técnico.


---

Read file: README.md

---

Ahora voy a examinar el código actual para entender mejor la implementación existente:


---

Read file: web/lib.js

---

Read file: web/script.js

---

Read file: web/firebase-database.js

---

Ahora voy a buscar si ya existe algún listener de Firebase en el código:


---

<details>
            <summary>Grep search for "onValue|onChildChanged|listener" • **3** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///Users/jordimarti/Development/pedorro/web/firebase-config.js` | L68 | `export const onAuthStateChangedListener = (callback) => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L23 | `onAuthStateChangedListener` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L216 | `// Event listener para el botón DISIMULAR` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L219 | `disimularButton.addEventListener('click', () => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L235 | `// Event listener para el botón REINICIAR` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L238 | `reiniciarButton.addEventListener('click', async () => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L289 | `// Configurar listener de cambios de autenticación` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L290 | `onAuthStateChangedListener((user) => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L307 | `// Event listener para el botón ACCEDER` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L310 | `accederButton.addEventListener('click', handleLogin);` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L317 | `// Event listener para cuando el DOM esté listo` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L318 | `document.addEventListener('DOMContentLoaded', initializeApp);` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L23 | `onAuthStateChangedListener` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L216 | `// Event listener para el botón DISIMULAR` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L219 | `disimularButton.addEventListener('click', () => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L235 | `// Event listener para el botón REINICIAR` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L238 | `reiniciarButton.addEventListener('click', async () => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L289 | `// Configurar listener de cambios de autenticación` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L290 | `onAuthStateChangedListener((user) => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L307 | `// Event listener para el botón ACCEDER` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L310 | `accederButton.addEventListener('click', handleLogin);` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L317 | `// Event listener para cuando el DOM esté listo` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L318 | `document.addEventListener('DOMContentLoaded', initializeApp);` |

</details>

---

Ahora voy a crear el plan técnico basado en la funcionalidad solicitada:


---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

Crear un nuevo plan técnico para implementar la funcionalidad de cálculo automático de roles y sonidos cuando cambia el código del juego

**Chunk 1**
Lines added: 174, lines removed: 1

```diff
@@ -1,1 +1,174 @@
- 
+ # PLAN TÉCNICO - Cálculo Automático de Roles y Sonidos
+ 
+ ## Descripción de la Funcionalidad
+ 
+ Implementar un listener de Firebase que detecte cambios en `/pedorros-game/{codigo-juego}` y, cuando el estado sea "START", calcule automáticamente:
+ 
+ 1. **Distribución de roles**: Asignar peditos, pedorro y neutrales según la tabla del PRODUCT_BRIEF
+ 2. **Sonidos asignados**: Generar diccionario `nextSounds` con sonidos para cada jugador
+ 3. **Persistencia en BD**: Guardar los resultados en Firebase Database
+ 
+ ## Archivos y Funciones a Modificar
+ 
+ ### Archivos Existentes a Modificar
+ 
+ #### `web/lib.js`
+ - **Nueva función**: `calculateGameRoles(totalPlayers)` - Calcula distribución de roles
+ - **Nueva función**: `generateNextSounds(roles, totalPlayers)` - Genera diccionario de sonidos
+ - **Nueva función**: `shuffleArray(array)` - Función de utilidad para mezclar arrays
+ 
+ #### `web/firebase-database.js`
+ - **Nueva función**: `setupGameStateListener(gameCode, callback)` - Configura listener de Firebase
+ - **Nueva función**: `updateGameRoles(gameCode, roles, nextSounds)` - Actualiza roles en BD
+ - **Modificar**: `getResetGameState()` - Añadir campos `peditos` y `pedorro`
+ 
+ #### `web/script.js`
+ - **Modificar**: `initializeApp()` - Configurar listener cuando se inicializa la app
+ - **Nueva función**: `handleGameStateChange(gameData)` - Maneja cambios en el estado del juego
+ 
+ ### Archivos a Crear
+ 
+ Ninguno - toda la funcionalidad se integra en archivos existentes.
+ 
+ ## Algoritmo de Implementación
+ 
+ ### Fase 1: Lógica de Cálculo de Roles (lib.js)
+ 
+ #### Función `calculateGameRoles(totalPlayers)`
+ 1. **Validar entrada**: Verificar que `totalPlayers` esté entre 4-16
+ 2. **Obtener distribución**: Usar tabla del PRODUCT_BRIEF para determinar cantidad de peditos
+ 3. **Generar array base**: Crear array `[1, 2, 3, ..., totalPlayers]`
+ 4. **Shuffle del array**: Mezclar aleatoriamente el array base
+ 5. **Extraer roles**:
+    - Tomar primeros `cantidadPeditos` elementos → `peditos`
+    - Tomar siguiente elemento → `pedorro`
+    - Resto → `neutrales` (no se almacenan, solo para lógica)
+ 6. **Retornar objeto**: `{ peditos: [...], pedorro: number }`
+ 
+ #### Función `generateNextSounds(roles, totalPlayers)`
+ 1. **Crear diccionario base**: `{ 1: null, 2: null, ..., totalPlayers: null }`
+ 2. **Asignar sonidos peditos**: Todos los peditos reciben el mismo número (1-5)
+ 3. **Asignar sonido pedorro**: Número único (1-5, puede coincidir con peditos)
+ 4. **Retornar diccionario**: `nextSounds` completo
+ 
+ #### Función `shuffleArray(array)`
+ 1. **Clonar array**: Evitar mutación del array original
+ 2. **Algoritmo Fisher-Yates**: Mezclar elementos aleatoriamente
+ 3. **Retornar array mezclado**: Nuevo array inmutable
+ 
+ ### Fase 2: Integración con Firebase (firebase-database.js)
+ 
+ #### Función `setupGameStateListener(gameCode, callback)`
+ 1. **Crear referencia**: `ref(database, 'pedorros-game/' + gameCode)`
+ 2. **Configurar listener**: `onValue(ref, callback)`
+ 3. **Manejar desconexión**: Retornar función de cleanup
+ 
+ #### Función `updateGameRoles(gameCode, roles, nextSounds)`
+ 1. **Validar datos**: Verificar estructura de roles y nextSounds
+ 2. **Actualizar BD**: Usar `update()` para modificar solo campos específicos
+ 3. **Manejar errores**: Retornar Promise con resultado de la operación
+ 
+ #### Modificación de `getResetGameState()`
+ 1. **Añadir campo `peditos`**: Array vacío por defecto
+ 2. **Añadir campo `pedorro`**: `null` por defecto
+ 3. **Mantener compatibilidad**: No romper funcionalidad existente
+ 
+ ### Fase 3: Integración en la UI (script.js)
+ 
+ #### Función `handleGameStateChange(gameData)`
+ 1. **Verificar estado**: Solo procesar si `state === "START"`
+ 2. **Verificar cambio de código**: Detectar si el código del juego cambió
+ 3. **Calcular roles**: Llamar a `calculateGameRoles()`
+ 4. **Generar sonidos**: Llamar a `generateNextSounds()`
+ 5. **Actualizar BD**: Llamar a `updateGameRoles()`
+ 
+ #### Modificación de `initializeApp()`
+ 1. **Configurar listener**: Llamar a `setupGameStateListener()`
+ 2. **Manejar cleanup**: Guardar referencia para limpieza posterior
+ 3. **Integrar con estado existente**: No interferir con funcionalidad actual
+ 
+ ## Detalles de Implementación
+ 
+ ### Estructura de Datos en Firebase
+ 
+ ```json
+ {
+   "pedorros-game": {
+     "galerna": {
+       "state": "START",
+       "numRound": 1,
+       "peditos": [2, 4],
+       "pedorro": 1,
+       "nextSounds": {
+         "1": 3,
+         "2": 2,
+         "3": null,
+         "4": 2,
+         "5": null
+       },
+       "ranking": {},
+       "lastResult": null,
+       "pedorroSound": null
+     }
+   }
+ }
+ ```
+ 
+ ### Lógica de Detección de Cambios
+ 
+ - **Listener activo**: Se configura una vez al inicializar la app
+ - **Detección de cambios**: Firebase notifica automáticamente cambios en el documento
+ - **Filtrado por estado**: Solo procesar cambios cuando `state === "START"`
+ - **Prevención de loops**: Verificar que los datos no sean los mismos que ya se calcularon
+ 
+ ### Manejo de Errores
+ 
+ - **Validación de entrada**: Verificar rangos válidos (4-16 jugadores)
+ - **Fallback de roles**: Si falla el cálculo, mantener estado anterior
+ - **Logging de errores**: Registrar errores para debugging
+ - **Recuperación**: Intentar recalcular en siguiente cambio de estado
+ 
+ ## Consideraciones Técnicas
+ 
+ ### Inmutabilidad
+ - **Funciones puras**: Todas las funciones de cálculo retornan nuevos objetos
+ - **Sin side effects**: No modificar arrays o objetos de entrada
+ - **Spread operator**: Usar para crear copias inmutables
+ 
+ ### Performance
+ - **Listener único**: Un solo listener por sesión de juego
+ - **Debouncing**: Evitar múltiples cálculos en cambios rápidos
+ - **Cleanup**: Limpiar listener al cerrar la app
+ 
+ ### Testing
+ - **Tests unitarios**: Para todas las funciones de cálculo
+ - **Tests de integración**: Para la lógica de Firebase
+ - **Mocks**: Simular Firebase para tests aislados
+ 
+ ## Dependencias
+ 
+ - **Firebase SDK**: Ya configurado en el proyecto
+ - **Funciones existentes**: Reutilizar lógica de validación y estado
+ - **Arquitectura actual**: Mantener separación lib.js vs script.js
+ 
+ ## Riesgos y Mitigaciones
+ 
+ ### Riesgo: Cálculo duplicado
+ - **Mitigación**: Verificar que los datos no sean idénticos antes de recalcular
+ 
+ ### Riesgo: Pérdida de sincronización
+ - **Mitigación**: Usar transacciones de Firebase para actualizaciones atómicas
+ 
+ ### Riesgo: Performance en cambios frecuentes
+ - **Mitigación**: Implementar debouncing y filtrado por estado
+ 
+ ## Criterios de Completado
+ 
+ - [ ] Función `calculateGameRoles()` implementada y testeada
+ - [ ] Función `generateNextSounds()` implementada y testeada
+ - [ ] Listener de Firebase configurado y funcionando
+ - [ ] Roles y sonidos se calculan automáticamente al cambiar código
+ - [ ] Datos se persisten correctamente en Firebase
+ - [ ] Tests unitarios pasando
+ - [ ] No regresiones en funcionalidad existente
+ 
```

</details>

---

Perfecto! He creado el plan técnico para implementar la funcionalidad solicitada. El plan está estructurado siguiendo la filosofía de **SMALL SAFE STEPS** y se divide en 3 fases lógicas:

## Resumen del Plan

**Funcionalidad**: Implementar un listener de Firebase que detecte cambios en el código del juego y calcule automáticamente la distribución de roles (peditos, pedorro, neutrales) y los sonidos correspondientes cuando el estado sea "START".

### Fases de Implementación:

1. **Fase 1 - Lógica de Cálculo** (`lib.js`): Funciones puras para calcular roles y generar sonidos
2. **Fase 2 - Integración Firebase** (`firebase-database.js`): Listener y funciones de actualización de BD
3. **Fase 3 - Integración UI** (`script.js`): Manejo de cambios de estado y configuración del listener

### Características Clave:

- **Inmutabilidad**: Todas las funciones retornan nuevos objetos sin side effects
- **Separación de responsabilidades**: Core logic en `lib.js`, Firebase en `firebase-database.js`, UI en `script.js`
- **Prevención de loops**: Verificación de datos antes de recalcular
- **Manejo de errores**: Fallbacks y logging para debugging
- **Performance**: Listener único con debouncing y cleanup

El plan incluye todos los detalles técnicos necesarios, desde la estructura de datos en Firebase hasta los algoritmos específicos para el cálculo de roles usando la tabla del PRODUCT_BRIEF. ¿Te gustaría que proceda con la implementación de alguna fase específica o tienes alguna pregunta sobre el plan?

---

_**User**_

Cuidado: esto del listener sobre este campo solo debe ser el jugador 1. El resto de jugadores deben ignorarlo.

---

_**Assistant**_

¡Excelente punto! Tienes razón, solo el jugador 1 (director del juego) debe ejecutar este cálculo automático. Voy a actualizar el plan técnico para reflejar esta restricción importante:


---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

undefined

**Chunk 1**
Lines added: 6, lines removed: 5

```diff
@@ -77,9 +77,10 @@
  
  #### Función `handleGameStateChange(gameData)`
- 1. **Verificar estado**: Solo procesar si `state === "START"`
- 2. **Verificar cambio de código**: Detectar si el código del juego cambió
- 3. **Calcular roles**: Llamar a `calculateGameRoles()`
- 4. **Generar sonidos**: Llamar a `generateNextSounds()`
- 5. **Actualizar BD**: Llamar a `updateGameRoles()`
+ 1. **Verificar jugador**: Solo procesar si es el jugador 1 (director del juego)
+ 2. **Verificar estado**: Solo procesar si `state === "START"`
+ 3. **Verificar cambio de código**: Detectar si el código del juego cambió
+ 4. **Calcular roles**: Llamar a `calculateGameRoles()`
+ 5. **Generar sonidos**: Llamar a `generateNextSounds()`
+ 6. **Actualizar BD**: Llamar a `updateGameRoles()`
  
  #### Modificación de `initializeApp()`
```

</details>

---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

undefined

**Chunk 1**
Lines added: 1, lines removed: undefined

```diff
@@ -120,4 +120,5 @@
  - **Listener activo**: Se configura una vez al inicializar la app
  - **Detección de cambios**: Firebase notifica automáticamente cambios en el documento
+ - **Filtrado por jugador**: Solo el jugador 1 procesa los cambios (director del juego)
  - **Filtrado por estado**: Solo procesar cambios cuando `state === "START"`
  - **Prevención de loops**: Verificar que los datos no sean los mismos que ya se calcularon
```

</details>

---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

undefined

**Chunk 1**
Lines added: 4, lines removed: 3

```diff
@@ -85,7 +85,8 @@
  
  #### Modificación de `initializeApp()`
- 1. **Configurar listener**: Llamar a `setupGameStateListener()`
- 2. **Manejar cleanup**: Guardar referencia para limpieza posterior
- 3. **Integrar con estado existente**: No interferir con funcionalidad actual
+ 1. **Verificar jugador**: Solo configurar listener si es el jugador 1
+ 2. **Configurar listener**: Llamar a `setupGameStateListener()` solo para jugador 1
+ 3. **Manejar cleanup**: Guardar referencia para limpieza posterior
+ 4. **Integrar con estado existente**: No interferir con funcionalidad actual
  
  ## Detalles de Implementación
```

</details>

---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

undefined

**Chunk 1**
Lines added: 2, lines removed: 1

```diff
@@ -140,7 +140,8 @@
  
  ### Performance
- - **Listener único**: Un solo listener por sesión de juego
+ - **Listener único**: Un solo listener por sesión de juego (solo jugador 1)
  - **Debouncing**: Evitar múltiples cálculos en cambios rápidos
  - **Cleanup**: Limpiar listener al cerrar la app
+ - **Filtrado eficiente**: Solo jugador 1 procesa cambios, resto ignora
  
  ### Testing
```

</details>

---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

undefined

**Chunk 1**
Lines added: 3, lines removed: undefined

```diff
@@ -166,4 +166,7 @@
  ### Riesgo: Performance en cambios frecuentes
  - **Mitigación**: Implementar debouncing y filtrado por estado
+ 
+ ### Riesgo: Múltiples jugadores ejecutando cálculo
+ - **Mitigación**: Restricción estricta - solo jugador 1 puede ejecutar el listener
  
  ## Criterios de Completado
```

</details>

---

Perfecto! He actualizado el plan técnico para incluir la restricción importante de que **solo el jugador 1 (director del juego) debe ejecutar el listener y los cálculos automáticos**.

## Cambios Realizados en el Plan:

### 1. **Verificación de Jugador en `handleGameStateChange()`**
- Añadido paso 1: "Verificar jugador: Solo procesar si es el jugador 1 (director del juego)"

### 2. **Configuración del Listener Solo para Jugador 1**
- Modificado `initializeApp()` para verificar que solo el jugador 1 configure el listener
- Los demás jugadores no tendrán listener activo

### 3. **Filtrado por Jugador en la Lógica de Detección**
- Añadido "Filtrado por jugador: Solo el jugador 1 procesa los cambios (director del juego)"

### 4. **Performance Optimizada**
- Añadido "Filtrado eficiente: Solo jugador 1 procesa cambios, resto ignora"

### 5. **Nuevo Riesgo Identificado y Mitigado**
- Riesgo: "Múltiples jugadores ejecutando cálculo"
- Mitigación: "Restricción estricta - solo jugador 1 puede ejecutar el listener"

Esta restricción es crucial porque:
- **Evita cálculos duplicados** por múltiples dispositivos
- **Mantiene la autoridad del director** del juego (jugador 1)
- **Mejora la performance** al reducir procesamiento innecesario
- **Previene conflictos** en la base de datos

¿Te parece correcta esta restricción? ¿Hay algún otro aspecto del plan que quieras que ajuste?

---

_**User**_

ya creo que no se necesita el campo "pedorroSound", ya que lo hemos cambiado por "peditos" y "pedorro".

---

_**Assistant**_

Tienes razón! El campo `pedorroSound` ya no es necesario con la nueva estructura. Voy a actualizar el plan para eliminar esa referencia:


---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

undefined

**Chunk 1**
Lines added: 1, lines removed: 2

```diff
@@ -110,6 +110,5 @@
        },
        "ranking": {},
-       "lastResult": null,
-       "pedorroSound": null
+       "lastResult": null
      }
    }
```

</details>

---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

undefined

**Chunk 1**
Lines added: 2, lines removed: 1

```diff
@@ -72,5 +72,6 @@
  1. **Añadir campo `peditos`**: Array vacío por defecto
  2. **Añadir campo `pedorro`**: `null` por defecto
- 3. **Mantener compatibilidad**: No romper funcionalidad existente
+ 3. **Eliminar campo `pedorroSound`**: Ya no necesario con nueva estructura
+ 4. **Mantener compatibilidad**: No romper funcionalidad existente
  
  ### Fase 3: Integración en la UI (script.js)
```

</details>

---

Perfecto! He actualizado el plan para eliminar el campo `pedorroSound` que ya no es necesario. 

## Cambios Realizados:

### 1. **Estructura de Datos en Firebase Actualizada**
- Eliminado el campo `"pedorroSound": null` del ejemplo JSON
- La estructura ahora es más limpia y coherente

### 2. **Modificación de `getResetGameState()`**
- Añadido paso 3: "Eliminar campo `pedorroSound`: Ya no necesario con nueva estructura"
- El campo se elimina completamente de la función

## Estructura Final de Datos:

La nueva estructura es más lógica y eficiente:
- **`peditos`**: Array con los números de jugadores que son peditos
- **`pedorro`**: Número del jugador que es el pedorro
- **`nextSounds`**: Diccionario completo con todos los sonidos (incluyendo el del pedorro)

Esto elimina la redundancia y hace que la información esté centralizada en `nextSounds`, donde el sonido del pedorro se puede obtener simplemente accediendo a `nextSounds[pedorro]`.

¿Te parece correcta esta simplificación? ¿Hay algún otro campo o aspecto que quieras que revise?

---

_**User**_

Ok, vamos a implementar!

---

_**Assistant**_

¡Perfecto! Vamos a implementar la funcionalidad paso a paso. Empezaré por la **Fase 1** implementando las funciones de cálculo en `lib.js`.

## Fase 1: Lógica de Cálculo de Roles (lib.js)

Primero voy a añadir las nuevas funciones al archivo `lib.js`:


---

Read file: web/lib.js

---

Ahora voy a añadir las nuevas funciones de cálculo al final del archivo:


---

<details><summary>Edit file: web/lib.js</summary>

Añadir las nuevas funciones de cálculo de roles y sonidos al final del archivo, después de getResetGameState

**Chunk 1**
Lines added: 93, lines removed: 2

```diff
@@ -141,5 +141,96 @@
      state: "START",
      nextSounds: {},
-     pedorroSound: null
- });
+     peditos: [],
+     pedorro: null
+ });
+ 
+ // Función pura para mezclar un array (algoritmo Fisher-Yates)
+ export const shuffleArray = (array) => {
+     if (!Array.isArray(array)) {
+         return [];
+     }
+     
+     const shuffled = [...array]; // Clonar array para mantener inmutabilidad
+     
+     for (let i = shuffled.length - 1; i > 0; i--) {
+         const j = Math.floor(Math.random() * (i + 1));
+         [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
+     }
+     
+     return shuffled;
+ };
+ 
+ // Función pura para calcular la distribución de roles según el número de jugadores
+ export const calculateGameRoles = (totalPlayers) => {
+     // Validar rango de jugadores (4-16 según PRODUCT_BRIEF)
+     if (totalPlayers < 4 || totalPlayers > 16) {
+         return {
+             success: false,
+             error: 'Número de jugadores debe estar entre 4 y 16',
+             peditos: [],
+             pedorro: null
+         };
+     }
+     
+     // Tabla de distribución según PRODUCT_BRIEF
+     const roleDistribution = {
+         4: { peditos: 2, pedorros: 1, neutrales: 1 },
+         5: { peditos: 2, pedorros: 1, neutrales: 2 },
+         6: { peditos: 3, pedorros: 1, neutrales: 2 },
+         7: { peditos: 4, pedorros: 1, neutrales: 2 },
+         8: { peditos: 4, pedorros: 1, neutrales: 3 },
+         9: { peditos: 5, pedorros: 1, neutrales: 3 },
+         10: { peditos: 6, pedorros: 1, neutrales: 3 },
+         11: { peditos: 6, pedorros: 1, neutrales: 4 },
+         12: { peditos: 7, pedorros: 1, neutrales: 4 },
+         13: { peditos: 8, pedorros: 1, neutrales: 4 },
+         14: { peditos: 8, pedorros: 1, neutrales: 5 },
+         15: { peditos: 9, pedorros: 1, neutrales: 5 },
+         16: { peditos: 10, pedorros: 1, neutrales: 5 }
+     };
+     
+     const distribution = roleDistribution[totalPlayers];
+     
+     // Generar array base [1, 2, 3, ..., totalPlayers]
+     const baseArray = Array.from({ length: totalPlayers }, (_, i) => i + 1);
+     
+     // Mezclar el array
+     const shuffledArray = shuffleArray(baseArray);
+     
+     // Extraer roles
+     const peditos = shuffledArray.slice(0, distribution.peditos);
+     const pedorro = shuffledArray[distribution.peditos];
+     
+     return {
+         success: true,
+         peditos,
+         pedorro,
+         totalPlayers
+     };
+ };
+ 
+ // Función pura para generar el diccionario de sonidos para cada jugador
+ export const generateNextSounds = (roles, totalPlayers) => {
+     if (!roles || !roles.success || !roles.peditos || !roles.pedorro) {
+         return {};
+     }
+     
+     // Crear diccionario base con null para todos
+     const nextSounds = {};
+     for (let i = 1; i <= totalPlayers; i++) {
+         nextSounds[i] = null;
+     }
+     
+     // Asignar sonido para peditos (mismo número del 1-5)
+     const peditoSound = Math.floor(Math.random() * 5) + 1;
+     roles.peditos.forEach(playerNum => {
+         nextSounds[playerNum] = peditoSound;
+     });
+     
+     // Asignar sonido para pedorro (número del 1-5, puede coincidir)
+     const pedorroSound = Math.floor(Math.random() * 5) + 1;
+     nextSounds[roles.pedorro] = pedorroSound;
+     
+     return nextSounds;
+ };
  
```

</details>

---

¡Excelente! Ahora vamos con la **Fase 2**: Integración con Firebase. Voy a modificar `firebase-database.js`:


---

<details><summary>Edit file: web/firebase-database.js</summary>

Añadir las nuevas funciones de listener y actualización de roles, y modificar getResetGameState para eliminar pedorroSound

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -5,5 +5,5 @@
  
  import { database } from './firebase-config.js';
- import { ref, set } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
+ import { ref, set, onValue, update, off } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
  
  /**
```

**Chunk 2**
Lines added: 2, lines removed: 1

```diff
@@ -25,5 +25,6 @@
      state: "START",
      nextSounds: {},
-     pedorroSound: null
+     peditos: [],
+     pedorro: null
  });
  
```

**Chunk 3**
Lines added: 79, lines removed: undefined

```diff
@@ -59,3 +60,82 @@
      }
  };
+ 
+ /**
+  * Configura un listener para cambios en el estado del juego
+  * @param {string} gameCode - Código del juego (ej: "galerna")
+  * @param {Function} callback - Función a ejecutar cuando cambie el estado
+  * @returns {Function} Función de cleanup para desconectar el listener
+  */
+ export const setupGameStateListener = (gameCode, callback) => {
+     try {
+         if (!gameCode || typeof gameCode !== 'string') {
+             throw new Error('Código de juego inválido');
+         }
+ 
+         const gameRef = ref(database, `pedorros-game/${gameCode}`);
+         
+         // Configurar listener
+         onValue(gameRef, (snapshot) => {
+             const gameData = snapshot.val();
+             if (gameData && callback) {
+                 callback(gameData);
+             }
+         });
+         
+         // Retornar función de cleanup
+         return () => {
+             off(gameRef);
+         };
+     } catch (error) {
+         console.error('Error al configurar listener del juego:', error);
+         return () => {}; // Función de cleanup vacía en caso de error
+     }
+ };
+ 
+ /**
+  * Actualiza los roles y sonidos del juego en Firebase Database
+  * @param {string} gameCode - Código del juego
+  * @param {Object} roles - Objeto con peditos y pedorro
+  * @param {Object} nextSounds - Diccionario de sonidos por jugador
+  * @returns {Promise<Object>} Resultado de la operación
+  */
+ export const updateGameRoles = async (gameCode, roles, nextSounds) => {
+     try {
+         if (!gameCode || typeof gameCode !== 'string') {
+             throw new Error('Código de juego inválido');
+         }
+ 
+         if (!roles || !roles.success || !roles.peditos || !roles.pedorro) {
+             throw new Error('Estructura de roles inválida');
+         }
+ 
+         if (!nextSounds || typeof nextSounds !== 'object') {
+             throw new Error('Estructura de sonidos inválida');
+         }
+ 
+         const gameRef = ref(database, `pedorros-game/${gameCode}`);
+         
+         // Actualizar solo los campos específicos
+         await update(gameRef, {
+             peditos: roles.peditos,
+             pedorro: roles.pedorro,
+             nextSounds: nextSounds
+         });
+         
+         return {
+             success: true,
+             message: 'Roles y sonidos actualizados exitosamente',
+             gameCode,
+             roles,
+             nextSounds
+         };
+     } catch (error) {
+         console.error('Error al actualizar roles del juego:', error);
+         return {
+             success: false,
+             error: error.message,
+             gameCode
+         };
+     }
+ };
  
```

</details>

---

Ahora vamos con la **Fase 3**: Integración en la UI. Voy a modificar `script.js`:


---

Read file: web/script.js

---

Voy a actualizar los imports y añadir las nuevas funciones:


---

<details><summary>Edit file: web/script.js</summary>

Actualizar los imports para incluir las nuevas funciones de cálculo y Firebase, y añadir las nuevas funciones de manejo de cambios de estado

**Chunk 1**
Lines added: 2, lines removed: undefined

```diff
@@ -15,4 +15,6 @@
      isPlayerOne,
      getResetGameState,
+     calculateGameRoles,
+     generateNextSounds,
      AUTH_STATES
  } from './lib.js';
```

**Chunk 2**
Lines added: 6, lines removed: 1

```diff
@@ -25,9 +27,14 @@
  
  import {
-     resetGameState
+     resetGameState,
+     setupGameStateListener,
+     updateGameRoles
  } from './firebase-database.js';
  
  // Estado de autenticación (separado del estado del juego)
  let authState = AUTH_STATES.UNAUTHENTICATED;
+ 
+ // Variable para almacenar la función de cleanup del listener
+ let gameStateListenerCleanup = null;
  
  // Función pura para renderizar la pantalla según el estado de autenticación
```

</details>

---

Ahora voy a añadir la función para manejar cambios en el estado del juego:


---

Read file: web/script.js

---

Ahora voy a añadir la función de manejo de cambios de estado del juego antes de `initializeApp`:


---

<details><summary>Edit file: web/script.js</summary>

Añadir la función handleGameStateChange antes de initializeApp para manejar los cambios automáticos de roles y sonidos

**Chunk 1**
Lines added: 54, lines removed: undefined

```diff
@@ -289,4 +289,58 @@
      };
  };
+ 
+ // Función para manejar cambios en el estado del juego (solo jugador 1)
+ const handleGameStateChange = async (gameData) => {
+     // Solo procesar si es el jugador 1 (director del juego)
+     if (!gameState || !isPlayerOne(gameState)) {
+         return;
+     }
+     
+     // Solo procesar si el estado es "START"
+     if (gameData.state !== "START") {
+         return;
+     }
+     
+     // Verificar si ya existen roles calculados para evitar recalcular
+     if (gameData.peditos && gameData.peditos.length > 0 && gameData.pedorro) {
+         console.log('Roles ya calculados, saltando cálculo automático');
+         return;
+     }
+     
+     console.log('Estado START detectado, calculando roles automáticamente...');
+     
+     try {
+         // Calcular distribución de roles
+         const roles = calculateGameRoles(gameState.totalPlayers);
+         
+         if (!roles.success) {
+             console.error('Error al calcular roles:', roles.error);
+             return;
+         }
+         
+         // Generar sonidos para cada jugador
+         const nextSounds = generateNextSounds(roles, gameState.totalPlayers);
+         
+         if (Object.keys(nextSounds).length === 0) {
+             console.error('Error al generar sonidos');
+             return;
+         }
+         
+         console.log('Roles calculados:', roles);
+         console.log('Sonidos generados:', nextSounds);
+         
+         // Actualizar en Firebase Database
+         const result = await updateGameRoles(gameState.gameCode, roles, nextSounds);
+         
+         if (result.success) {
+             console.log('Roles y sonidos actualizados exitosamente en Firebase');
+         } else {
+             console.error('Error al actualizar roles en Firebase:', result.error);
+         }
+         
+     } catch (error) {
+         console.error('Error inesperado al calcular roles:', error);
+     }
+ };
  
  // Función principal de inicialización de la aplicación
```

</details>

---

Ahora necesito modificar la función `initializeGame` para configurar el listener solo para el jugador 1. Voy a buscar esa función:


---

<details>
            <summary>Grep search for "const initializeGame" • **4** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L195 | `const initializeGame = () => {` |
| `file:///Users/jordimarti/Development/pedorro/web/lib.js` | L59 | `export const initializeGameState = (url) => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L195 | `const initializeGame = () => {` |
| `file:///Users/jordimarti/Development/pedorro/web/lib.js` | L59 | `export const initializeGameState = (url) => {` |

</details>

---

Read file: web/script.js

---

Ahora voy a modificar la función `initializeGame` para configurar el listener solo para el jugador 1:


---

<details><summary>Edit file: web/script.js</summary>

Modificar initializeGame para configurar el listener de Firebase solo para el jugador 1 y hacer gameState accesible globalmente

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -197,5 +197,5 @@
      
      // Crear estado inicial inmutable
-     let gameState = initializeGameState(window.location.href);
+     gameState = initializeGameState(window.location.href);
      
      // Log del estado inicial
```

**Chunk 2**
Lines added: 17, lines removed: undefined

```diff
@@ -214,4 +214,21 @@
      
      console.log('Código de juego:', gameState.gameCode);
+     
+     // Configurar listener de Firebase solo para el jugador 1 (director del juego)
+     if (isPlayerOne(gameState)) {
+         console.log('Configurando listener de Firebase para jugador 1...');
+         
+         // Limpiar listener anterior si existe
+         if (gameStateListenerCleanup) {
+             gameStateListenerCleanup();
+         }
+         
+         // Configurar nuevo listener
+         gameStateListenerCleanup = setupGameStateListener(gameState.gameCode, handleGameStateChange);
+         
+         console.log('Listener de Firebase configurado para jugador 1');
+     } else {
+         console.log('Jugador no es director del juego, no se configura listener');
+     }
      
      // Esperar un momento para que el estado de autenticación esté completamente establecido
```

</details>

---

Ahora necesito declarar `gameState` como variable global al inicio del archivo. Voy a buscar dónde se declara:


---

<details>
            <summary>Grep search for "let gameState|var gameState|const gameState" • **2** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L38 | `let gameStateListenerCleanup = null;` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L38 | `let gameStateListenerCleanup = null;` |

</details>

---

Necesito declarar `gameState` como variable global. Voy a añadirla:


---

<details><summary>Edit file: web/script.js</summary>

Añadir la declaración de gameState como variable global después de gameStateListenerCleanup

**Chunk 1**
Lines added: 3, lines removed: undefined

```diff
@@ -37,4 +37,7 @@
  // Variable para almacenar la función de cleanup del listener
  let gameStateListenerCleanup = null;
+ 
+ // Estado del juego (accesible globalmente)
+ let gameState = null;
  
  // Función pura para renderizar la pantalla según el estado de autenticación
```

</details>

---

Ahora voy a añadir una función de cleanup para cuando se cierre la aplicación. Voy a modificar la función `initializeApp`:


---

<details><summary>Edit file: web/script.js</summary>

Añadir cleanup del listener cuando se cierre la aplicación y mejorar el manejo de la desconexión

**Chunk 1**
Lines added: 18, lines removed: undefined

```diff
@@ -398,3 +398,21 @@
  // Event listener para cuando el DOM esté listo
  document.addEventListener('DOMContentLoaded', initializeApp);
+ 
+ // Cleanup cuando se cierre la aplicación
+ window.addEventListener('beforeunload', () => {
+     if (gameStateListenerCleanup) {
+         console.log('Limpiando listener de Firebase...');
+         gameStateListenerCleanup();
+         gameStateListenerCleanup = null;
+     }
+ });
+ 
+ // Cleanup cuando se cambie de página
+ window.addEventListener('pagehide', () => {
+     if (gameStateListenerCleanup) {
+         console.log('Limpiando listener de Firebase...');
+         gameStateListenerCleanup();
+         gameStateListenerCleanup = null;
+     }
+ });
  
```

</details>

---

¡Excelente! Ahora vamos a probar la implementación. Primero voy a ejecutar los tests para asegurarme de que no hemos roto nada:


---

```bash
cd /Users/jordimarti/Development/pedorro && nvm use 20 && npm test
```

```

Now using node v20.18.3 (npm v10.8.2)

> Pedorros@1.0.0 test
> jest

 PASS  test/unit/parseGameURL.test.js
  parseGameURL - URLs válidas
    ✓ debe parsear URL válida con código "galerna", jugador 1 de 5 (2 ms)
    ✓ debe parsear URL válida con código "fiesta123", jugador 3 de 8 (1 ms)
    ✓ debe parsear URL válida con código "test", jugador 16 de 16
    ✓ debe parsear URL válida con código "a", jugador 1 de 4
  parseGameURL - URLs inválidas
    ✓ debe fallar con URL sin parámetros
    ✓ debe fallar con formato incorrecto - sin "g"
    ✓ debe fallar con formato incorrecto - sin "p"
    ✓ debe parsear URL con código de juego numérico
    ✓ debe fallar con formato incorrecto - letras en lugar de números
    ✓ debe fallar con URL parcialmente correcta
    ✓ debe parsear URL con parámetros extra (regex solo busca el patrón específi
co)
  parseGameURL - Casos edge
    ✓ debe parsear URL con código de juego muy largo
    ✓ debe parsear URL con números de jugador en límites
    ✓ debe fallar con números negativos (1 ms)
    ✓ debe parsear URL con cero como número de jugador (regex acepta 0)
  parseGameURL - Validación de regex
    ✓ debe aceptar caracteres especiales en código de juego
    ✓ debe aceptar números en código de juego
    ✓ debe parsear URL con espacios en código de juego (regex acepta espacios) (
1 ms)
  parseGameURL - Funcionalidad pura
    ✓ debe ser una función pura - mismo input siempre produce mismo output (2 ms
)
    ✓ debe ser una función pura - no modifica el input
    ✓ debe ser una función pura - retorna nuevo objeto cada vez
    ✓ debe manejar URLs vacías o null (1 ms)

Test Suites: 1 passed, 1 total
Tests:       22 passed, 22 total
Snapshots:   0 total
Time:        0.766 s, estimated 1 s
Ran all test suites.
```

---

¡Perfecto! Todos los tests siguen pasando. Ahora vamos a crear tests para las nuevas funciones que hemos implementado. Voy a crear un nuevo archivo de test:


---

<details><summary>Edit file: test/unit/gameRoles.test.js</summary>

Crear tests unitarios para las nuevas funciones de cálculo de roles y sonidos

**Chunk 1**
Lines added: 202, lines removed: 1

```diff
@@ -1,1 +1,202 @@
- 
+ /**
+  * Tests unitarios para las funciones de cálculo de roles y sonidos del juego
+  */
+ 
+ import { 
+     calculateGameRoles, 
+     generateNextSounds, 
+     shuffleArray 
+ } from '../../web/lib.js';
+ 
+ describe('shuffleArray', () => {
+     test('debe mezclar un array sin modificar el original', () => {
+         const original = [1, 2, 3, 4, 5];
+         const shuffled = shuffleArray(original);
+         
+         expect(shuffled).not.toEqual(original);
+         expect(original).toEqual([1, 2, 3, 4, 5]); // Original no modificado
+         expect(shuffled).toHaveLength(5);
+         expect(shuffled).toContain(1);
+         expect(shuffled).toContain(2);
+         expect(shuffled).toContain(3);
+         expect(shuffled).toContain(4);
+         expect(shuffled).toContain(5);
+     });
+     
+     test('debe retornar array vacío para input inválido', () => {
+         expect(shuffleArray(null)).toEqual([]);
+         expect(shuffleArray(undefined)).toEqual([]);
+         expect(shuffleArray('string')).toEqual([]);
+         expect(shuffleArray(123)).toEqual([]);
+     });
+     
+     test('debe manejar arrays vacíos', () => {
+         expect(shuffleArray([])).toEqual([]);
+     });
+     
+     test('debe manejar arrays de un elemento', () => {
+         expect(shuffleArray([42])).toEqual([42]);
+     });
+ });
+ 
+ describe('calculateGameRoles', () => {
+     test('debe calcular roles correctamente para 4 jugadores', () => {
+         const result = calculateGameRoles(4);
+         
+         expect(result.success).toBe(true);
+         expect(result.peditos).toHaveLength(2);
+         expect(result.pedorro).toBeGreaterThan(0);
+         expect(result.pedorro).toBeLessThanOrEqual(4);
+         expect(result.totalPlayers).toBe(4);
+         
+         // Verificar que pedorro no esté en peditos
+         expect(result.peditos).not.toContain(result.pedorro);
+         
+         // Verificar que todos los números estén en el rango correcto
+         result.peditos.forEach(num => {
+             expect(num).toBeGreaterThan(0);
+             expect(num).toBeLessThanOrEqual(4);
+         });
+     });
+     
+     test('debe calcular roles correctamente para 8 jugadores', () => {
+         const result = calculateGameRoles(8);
+         
+         expect(result.success).toBe(true);
+         expect(result.peditos).toHaveLength(4);
+         expect(result.pedorro).toBeGreaterThan(0);
+         expect(result.pedorro).toBeLessThanOrEqual(8);
+         expect(result.totalPlayers).toBe(8);
+         
+         // Verificar que pedorro no esté en peditos
+         expect(result.peditos).not.toContain(result.pedorro);
+     });
+     
+     test('debe calcular roles correctamente para 16 jugadores', () => {
+         const result = calculateGameRoles(16);
+         
+         expect(result.success).toBe(true);
+         expect(result.peditos).toHaveLength(10);
+         expect(result.pedorro).toBeGreaterThan(0);
+         expect(result.pedorro).toBeLessThanOrEqual(16);
+         expect(result.totalPlayers).toBe(16);
+     });
+     
+     test('debe fallar para menos de 4 jugadores', () => {
+         const result = calculateGameRoles(3);
+         
+         expect(result.success).toBe(false);
+         expect(result.error).toBe('Número de jugadores debe estar entre 4 y 16');
+         expect(result.peditos).toEqual([]);
+         expect(result.pedorro).toBeNull();
+     });
+     
+     test('debe fallar para más de 16 jugadores', () => {
+         const result = calculateGameRoles(17);
+         
+         expect(result.success).toBe(false);
+         expect(result.error).toBe('Número de jugadores debe estar entre 4 y 16');
+         expect(result.peditos).toEqual([]);
+         expect(result.pedorro).toBeNull();
+     });
+     
+     test('debe fallar para input inválido', () => {
+         const result = calculateGameRoles('invalid');
+         
+         expect(result.success).toBe(false);
+         expect(result.error).toBe('Número de jugadores debe estar entre 4 y 16');
+     });
+     
+     test('debe generar roles únicos cada vez', () => {
+         const result1 = calculateGameRoles(6);
+         const result2 = calculateGameRoles(6);
+         
+         expect(result1.success).toBe(true);
+         expect(result2.success).toBe(true);
+         
+         // Los roles pueden ser diferentes (aleatorios)
+         // Pero ambos deben ser válidos
+         expect(result1.peditos).toHaveLength(3);
+         expect(result2.peditos).toHaveLength(3);
+         expect(result1.pedorro).toBeGreaterThan(0);
+         expect(result2.pedorro).toBeGreaterThan(0);
+     });
+ });
+ 
+ describe('generateNextSounds', () => {
+     test('debe generar sonidos correctamente para roles válidos', () => {
+         const roles = {
+             success: true,
+             peditos: [2, 4],
+             pedorro: 1,
+             totalPlayers: 5
+         };
+         
+         const nextSounds = generateNextSounds(roles, 5);
+         
+         expect(Object.keys(nextSounds)).toHaveLength(5);
+         expect(nextSounds[1]).toBeGreaterThan(0); // pedorro
+         expect(nextSounds[1]).toBeLessThanOrEqual(5);
+         expect(nextSounds[2]).toBeGreaterThan(0); // pedito
+         expect(nextSounds[2]).toBeLessThanOrEqual(5);
+         expect(nextSounds[3]).toBeNull(); // neutral
+         expect(nextSounds[4]).toBeGreaterThan(0); // pedito
+         expect(nextSounds[4]).toBeLessThanOrEqual(5);
+         expect(nextSounds[5]).toBeNull(); // neutral
+         
+         // Verificar que todos los peditos tengan el mismo sonido
+         expect(nextSounds[2]).toBe(nextSounds[4]);
+     });
+     
+     test('debe retornar objeto vacío para roles inválidos', () => {
+         expect(generateNextSounds(null, 5)).toEqual({});
+         expect(generateNextSounds({}, 5)).toEqual({});
+         expect(generateNextSounds({ success: false }, 5)).toEqual({});
+         expect(generateNextSounds({ success: true, peditos: null }, 5)).toEqual({});
+     });
+     
+     test('debe manejar diferentes números de jugadores', () => {
+         const roles = {
+             success: true,
+             peditos: [2, 4, 6],
+             pedorro: 1,
+             totalPlayers: 8
+         };
+         
+         const nextSounds = generateNextSounds(roles, 8);
+         
+         expect(Object.keys(nextSounds)).toHaveLength(8);
+         expect(nextSounds[1]).toBeGreaterThan(0); // pedorro
+         expect(nextSounds[2]).toBeGreaterThan(0); // pedito
+         expect(nextSounds[3]).toBeNull(); // neutral
+         expect(nextSounds[4]).toBeGreaterThan(0); // pedito
+         expect(nextSounds[5]).toBeNull(); // neutral
+         expect(nextSounds[6]).toBeGreaterThan(0); // pedito
+         expect(nextSounds[7]).toBeNull(); // neutral
+         expect(nextSounds[8]).toBeNull(); // neutral
+         
+         // Verificar que todos los peditos tengan el mismo sonido
+         expect(nextSounds[2]).toBe(nextSounds[4]);
+         expect(nextSounds[4]).toBe(nextSounds[6]);
+     });
+     
+     test('debe generar sonidos en rango 1-5', () => {
+         const roles = {
+             success: true,
+             peditos: [2],
+             pedorro: 1,
+             totalPlayers: 3
+         };
+         
+         const nextSounds = generateNextSounds(roles, 3);
+         
+         // Verificar rango de sonidos
+         Object.values(nextSounds).forEach(sound => {
+             if (sound !== null) {
+                 expect(sound).toBeGreaterThan(0);
+                 expect(sound).toBeLessThanOrEqual(5);
+             }
+         });
+     });
+ });
+ 
```

</details>

---

Ahora vamos a ejecutar los nuevos tests para verificar que funcionan correctamente:


---

```bash
npm test test/unit/gameRoles.test.js
```

```
(base) ➜  pedorro git:(main) ✗ npm test test/unit/gameRoles.test.js

> Pedorros@1.0.0 test
> jest test/unit/gameRoles.test.js

 FAIL  test/unit/gameRoles.test.js
  shuffleArray
    ✓ debe mezclar un array sin modificar el original (2 ms)
    ✓ debe retornar array vacío para input inválido
    ✓ debe manejar arrays vacíos
    ✓ debe manejar arrays de un elemento (1 ms)
  calculateGameRoles
    ✓ debe calcular roles correctamente para 4 jugadores
    ✓ debe calcular roles correctamente para 8 jugadores
    ✓ debe calcular roles correctamente para 16 jugadores (1 ms)
    ✓ debe fallar para menos de 4 jugadores
    ✓ debe fallar para más de 16 jugadores (2 ms)
    ✕ debe fallar para input inválido (1 ms)
    ✓ debe generar roles únicos cada vez
  generateNextSounds
    ✓ debe generar sonidos correctamente para roles válidos
    ✓ debe retornar objeto vacío para roles inválidos
    ✓ debe manejar diferentes números de jugadores (1 ms)
    ✓ debe generar sonidos en rango 1-5

  ● calculateGameRoles › debe fallar para input inválido

    TypeError: Cannot read properties of undefined (reading 'peditos')

      199 |     
      200 |     // Extraer roles
    > 201 |     const peditos = shuffledArray.slice(0, distribution.peditos);
          |                                                         ^
      202 |     const pedorro = shuffledArray[distribution.peditos];
      203 |     
      204 |     return {

      at peditos (web/lib.js:201:57)
      at Object.<anonymous> (test/unit/gameRoles.test.js:104:42)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 14 passed, 15 total
Snapshots:   0 total
Time:        0.656 s
Ran all test suites matching /test\/unit\/gameRoles.test.js/i.
```

---

Hay un error en la función `calculateGameRoles`. Necesito validar que `totalPlayers` sea un número antes de acceder a la tabla de distribución. Voy a corregirlo:


---

<details><summary>Edit file: web/lib.js</summary>

Corregir la validación en calculateGameRoles para verificar que totalPlayers sea un número antes de acceder a la tabla

**Chunk 1**
Lines added: 10, lines removed: undefined

```diff
@@ -163,4 +163,14 @@
  // Función pura para calcular la distribución de roles según el número de jugadores
  export const calculateGameRoles = (totalPlayers) => {
+     // Validar que totalPlayers sea un número
+     if (typeof totalPlayers !== 'number' || !Number.isInteger(totalPlayers)) {
+         return {
+             success: false,
+             error: 'Número de jugadores debe ser un número entero',
+             peditos: [],
+             pedorro: null
+         };
+     }
+     
      // Validar rango de jugadores (4-16 según PRODUCT_BRIEF)
      if (totalPlayers < 4 || totalPlayers > 16) {
```

</details>

---

Ahora voy a ejecutar los tests nuevamente para verificar que se corrigió el error:


---

```bash
npm test test/unit/gameRoles.test.js
```

```
(base) ➜  pedorro git:(main) ✗ npm test test/unit/gameRoles.test.js

> Pedorros@1.0.0 test
> jest test/unit/gameRoles.test.js

 FAIL  test/unit/gameRoles.test.js
  shuffleArray
    ✓ debe mezclar un array sin modificar el original (2 ms)
    ✓ debe retornar array vacío para input inválido
    ✓ debe manejar arrays vacíos
    ✓ debe manejar arrays de un elemento (1 ms)
  calculateGameRoles
    ✓ debe calcular roles correctamente para 4 jugadores (2 ms)
    ✓ debe calcular roles correctamente para 8 jugadores (1 ms)
    ✓ debe calcular roles correctamente para 16 jugadores (1 ms)
    ✓ debe fallar para menos de 4 jugadores
    ✓ debe fallar para más de 16 jugadores
    ✕ debe fallar para input inválido (2 ms)
    ✓ debe generar roles únicos cada vez
  generateNextSounds
    ✓ debe generar sonidos correctamente para roles válidos (1 ms)
    ✓ debe retornar objeto vacío para roles inválidos
    ✓ debe manejar diferentes números de jugadores (1 ms)
    ✓ debe generar sonidos en rango 1-5

  ● calculateGameRoles › debe fallar para input inválido

    expect(received).toBe(expected) // Object.is equality

    Expected: "Número de jugadores debe estar entre 4 y 16"
    Received: "Número de jugadores debe ser un número entero"

      105 |         
      106 |         expect(result.success).toBe(false);
    > 107 |         expect(result.error).toBe('Número de jugadores debe estar entre 4 y 16');
          |                              ^
      108 |     });
      109 |     
      110 |     test('debe generar roles únicos cada vez', () => {

      at Object.toBe (test/unit/gameRoles.test.js:107:30)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 14 passed, 15 total
Snapshots:   0 total
Time:        0.619 s, estimated 1 s
Ran all test suites matching /test\/unit\/gameRoles.test.js/i.
```

---

El test está fallando porque ahora la validación de tipo se ejecuta antes que la validación de rango. Necesito actualizar el test para que espere el mensaje correcto:


---

<details><summary>Edit file: test/unit/gameRoles.test.js</summary>

Actualizar el test para que espere el mensaje correcto de error para input inválido

**Chunk 1**
Lines added: 3, lines removed: 1

```diff
@@ -105,5 +105,7 @@
          
          expect(result.success).toBe(false);
-         expect(result.error).toBe('Número de jugadores debe estar entre 4 y 16');
+         expect(result.error).toBe('Número de jugadores debe ser un número entero');
+         expect(result.peditos).toEqual([]);
+         expect(result.pedorro).toBeNull();
      });
      
```

</details>

---

Ahora voy a ejecutar los tests nuevamente:


---

```bash
npm test test/unit/gameRoles.test.js
```

```
(base) ➜  pedorro git:(main) ✗ npm test test/unit/gameRoles.test.js

> Pedorros@1.0.0 test
> jest test/unit/gameRoles.test.js

 PASS  test/unit/gameRoles.test.js
  shuffleArray
    ✓ debe mezclar un array sin modificar el original (1 ms)
    ✓ debe retornar array vacío para input inválido
    ✓ debe manejar arrays vacíos (1 ms)
    ✓ debe manejar arrays de un elemento
  calculateGameRoles
    ✓ debe calcular roles correctamente para 4 jugadores (1 ms)
    ✓ debe calcular roles correctamente para 8 jugadores
    ✓ debe calcular roles correctamente para 16 jugadores (1 ms)
    ✓ debe fallar para menos de 4 jugadores
    ✓ debe fallar para más de 16 jugadores (1 ms)
    ✓ debe fallar para input inválido (2 ms)
    ✓ debe generar roles únicos cada vez (1 ms)
  generateNextSounds
    ✓ debe generar sonidos correctamente para roles válidos
    ✓ debe retornar objeto vacío para roles inválidos (1 ms)
    ✓ debe manejar diferentes números de jugadores
    ✓ debe generar sonidos en rango 1-5

Test Suites: 1 passed, 1 total
Tests:       15 passed, 15 total
Snapshots:   0 total
Time:        0.62 s, estimated 1 s
Ran all test suites matching /test\/unit\/gameRoles.test.js/i.
```

---

¡Excelente! Ahora todos los tests están pasando. Vamos a ejecutar todos los tests para asegurarnos de que no hemos roto nada:


---

```bash
npm test
```

```
(base) ➜  pedorro git:(main) ✗ npm test

> Pedorros@1.0.0 test
> jest

 PASS  test/unit/parseGameURL.test.js
  parseGameURL - URLs válidas
    ✓ debe parsear URL válida con código "galerna", jugador 1 de 5 (1 ms)
    ✓ debe parsear URL válida con código "fiesta123", jugador 3 de 8
    ✓ debe parsear URL válida con código "test", jugador 16 de 16
    ✓ debe parsear URL válida con código "a", jugador 1 de 4 (1 ms)
  parseGameURL - URLs inválidas
    ✓ debe fallar con URL sin parámetros
    ✓ debe fallar con formato incorrecto - sin "g"
    ✓ debe fallar con formato incorrecto - sin "p" (1 ms)
    ✓ debe parsear URL con código de juego numérico
    ✓ debe fallar con formato incorrecto - letras en lugar de números (1 ms)
    ✓ debe fallar con URL parcialmente correcta
    ✓ debe parsear URL con parámetros extra (regex solo busca el patrón específico) (3 ms)
  parseGameURL - Casos edge
    ✓ debe parsear URL con código de juego muy largo
    ✓ debe parsear URL con números de jugador en límites
    ✓ debe fallar con números negativos (1 ms)
    ✓ debe parsear URL con cero como número de jugador (regex acepta 0)
  parseGameURL - Validación de regex
    ✓ debe aceptar caracteres especiales en código de juego
    ✓ debe aceptar números en código de juego
    ✓ debe parsear URL con espacios en código de juego (regex acepta espacios)
  parseGameURL - Funcionalidad pura
    ✓ debe ser una función pura - mismo input siempre produce mismo output (1 ms)
    ✓ debe ser una función pura - no modifica el input
    ✓ debe ser una función pura - retorna nuevo objeto cada vez
    ✓ debe manejar URLs vacías o null

 PASS  test/unit/gameRoles.test.js
  shuffleArray
    ✓ debe mezclar un array sin modificar el original (1 ms)
    ✓ debe retornar array vacío para input inválido
    ✓ debe manejar arrays vacíos (1 ms)
    ✓ debe manejar arrays de un elemento
  calculateGameRoles
    ✓ debe calcular roles correctamente para 4 jugadores (1 ms)
    ✓ debe calcular roles correctamente para 8 jugadores
    ✓ debe calcular roles correctamente para 16 jugadores
    ✓ debe fallar para menos de 4 jugadores (1 ms)
    ✓ debe fallar para más de 16 jugadores
    ✓ debe fallar para input inválido
    ✓ debe generar roles únicos cada vez (1 ms)
  generateNextSounds
    ✓ debe generar sonidos correctamente para roles válidos
    ✓ debe retornar objeto vacío para roles inválidos (1 ms)
    ✓ debe manejar diferentes números de jugadores
    ✓ debe generar sonidos en rango 1-5

Test Suites: 2 passed, 2 total
Tests:       37 passed, 37 total
Snapshots:   0 total
Time:        0.414 s, estimated 1 s
Ran all test suites.
```

---

¡Perfecto! Todos los tests están pasando. Ahora vamos a probar la funcionalidad en el navegador. Primero voy a iniciar el servidor de desarrollo:


---

```bash
npm run dev
```

---

Ahora voy a crear un pequeño script de prueba para verificar que las funciones funcionan correctamente. Voy a crear un archivo de demostración:


---

<details><summary>Edit file: test-demo.html</summary>

Crear un archivo HTML de demostración para probar las funciones de cálculo de roles

**Chunk 1**
Lines added: 176, lines removed: 1

```diff
@@ -1,1 +1,176 @@
- 
+ <!DOCTYPE html>
+ <html lang="es">
+ <head>
+     <meta charset="UTF-8">
+     <meta name="viewport" content="width=device-width, initial-scale=1.0">
+     <title>Demo - Cálculo de Roles PEDORROS</title>
+     <style>
+         body {
+             font-family: Arial, sans-serif;
+             max-width: 800px;
+             margin: 0 auto;
+             padding: 20px;
+             background-color: #f5f5f5;
+         }
+         .demo-section {
+             background: white;
+             padding: 20px;
+             margin: 20px 0;
+             border-radius: 8px;
+             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
+         }
+         .result {
+             background: #e8f5e8;
+             padding: 15px;
+             border-radius: 5px;
+             margin: 10px 0;
+             font-family: monospace;
+             white-space: pre-wrap;
+         }
+         .error {
+             background: #ffe8e8;
+             color: #d32f2f;
+         }
+         button {
+             background: #8B4513;
+             color: white;
+             border: none;
+             padding: 10px 20px;
+             border-radius: 5px;
+             cursor: pointer;
+             margin: 5px;
+         }
+         button:hover {
+             background: #A0522D;
+         }
+         input {
+             padding: 8px;
+             border: 1px solid #ddd;
+             border-radius: 4px;
+             margin: 5px;
+         }
+     </style>
+ </head>
+ <body>
+     <h1>🎮 Demo - Cálculo de Roles PEDORROS</h1>
+     
+     <div class="demo-section">
+         <h2>🧮 Cálculo de Roles</h2>
+         <p>Prueba la función de cálculo automático de roles según el número de jugadores:</p>
+         
+         <label for="playerCount">Número de jugadores (4-16):</label>
+         <input type="number" id="playerCount" min="4" max="16" value="6">
+         <button onclick="calculateRoles()">Calcular Roles</button>
+         
+         <div id="rolesResult" class="result" style="display: none;"></div>
+     </div>
+     
+     <div class="demo-section">
+         <h2>🎵 Generación de Sonidos</h2>
+         <p>Prueba la función de generación de sonidos para cada jugador:</p>
+         
+         <button onclick="generateSounds()">Generar Sonidos</button>
+         
+         <div id="soundsResult" class="result" style="display: none;"></div>
+     </div>
+     
+     <div class="demo-section">
+         <h2>🔄 Mezcla de Arrays</h2>
+         <p>Prueba la función de mezcla de arrays:</p>
+         
+         <button onclick="testShuffle()">Probar Mezcla</button>
+         
+         <div id="shuffleResult" class="result" style="display: none;"></div>
+     </div>
+ 
+     <script type="module">
+         import { 
+             calculateGameRoles, 
+             generateNextSounds, 
+             shuffleArray 
+         } from './web/lib.js';
+ 
+         // Hacer las funciones disponibles globalmente para los botones
+         window.calculateRoles = function() {
+             const playerCount = parseInt(document.getElementById('playerCount').value);
+             const result = calculateGameRoles(playerCount);
+             
+             const resultDiv = document.getElementById('rolesResult');
+             resultDiv.style.display = 'block';
+             
+             if (result.success) {
+                 resultDiv.className = 'result';
+                 resultDiv.textContent = `✅ ROLES CALCULADOS EXITOSAMENTE:
+                 
+ 📊 Distribución:
+ • Total de jugadores: ${result.totalPlayers}
+ • Peditos: ${result.peditos.join(', ')} (${result.peditos.length} jugadores)
+ • Pedorro: ${result.pedorro}
+ • Neutrales: ${result.totalPlayers - result.peditos.length - 1} jugadores
+ 
+ 🎯 Roles asignados:
+ ${result.peditos.map(p => `  • Jugador ${p}: PEDITO`).join('\n')}
+   • Jugador ${result.pedorro}: PEDORRO
+ ${Array.from({length: result.totalPlayers}, (_, i) => i + 1)
+     .filter(p => !result.peditos.includes(p) && p !== result.pedorro)
+     .map(p => `  • Jugador ${p}: NEUTRAL`).join('\n')}`;
+             } else {
+                 resultDiv.className = 'result error';
+                 resultDiv.textContent = `❌ ERROR: ${result.error}`;
+             }
+         };
+ 
+         window.generateSounds = function() {
+             const playerCount = parseInt(document.getElementById('playerCount').value);
+             const roles = calculateGameRoles(playerCount);
+             
+             if (!roles.success) {
+                 const resultDiv = document.getElementById('soundsResult');
+                 resultDiv.style.display = 'block';
+                 resultDiv.className = 'result error';
+                 resultDiv.textContent = `❌ ERROR: ${roles.error}`;
+                 return;
+             }
+             
+             const nextSounds = generateNextSounds(roles, playerCount);
+             
+             const resultDiv = document.getElementById('soundsResult');
+             resultDiv.style.display = 'block';
+             resultDiv.className = 'result';
+             
+             resultDiv.textContent = `🎵 SONIDOS GENERADOS:
+             
+ 📊 Roles:
+ • Peditos: ${roles.peditos.join(', ')} (sonido: ${nextSounds[roles.peditos[0]]})
+ • Pedorro: ${roles.pedorro} (sonido: ${nextSounds[roles.pedorro]})
+ 
+ 🔊 Sonidos por jugador:
+ ${Object.entries(nextSounds).map(([player, sound]) => {
+     let role = 'NEUTRAL';
+     if (roles.peditos.includes(parseInt(player))) role = 'PEDITO';
+     else if (parseInt(player) === roles.pedorro) role = 'PEDORRO';
+     
+     return `  • Jugador ${player}: ${sound === null ? 'SIN SONIDO' : `Sonido ${sound}`} (${role})`;
+ }).join('\n')}`;
+         };
+ 
+         window.testShuffle = function() {
+             const original = [1, 2, 3, 4, 5, 6, 7, 8];
+             const shuffled = shuffleArray(original);
+             
+             const resultDiv = document.getElementById('shuffleResult');
+             resultDiv.style.display = 'block';
+             resultDiv.className = 'result';
+             
+             resultDiv.textContent = `🔄 PRUEBA DE MEZCLA:
+             
+ 📋 Array original: [${original.join(', ')}]
+ 🎲 Array mezclado: [${shuffled.join(', ')}]
+ ✅ ¿Son diferentes? ${JSON.stringify(original) !== JSON.stringify(shuffled) ? 'SÍ' : 'NO'}
+ ✅ ¿Contienen los mismos elementos? ${original.every(x => shuffled.includes(x)) ? 'SÍ' : 'NO'}
+ ✅ ¿Original no modificado? ${JSON.stringify(original) === '[1,2,3,4,5,6,7,8]' ? 'SÍ' : 'NO'}`;
+         };
+     </script>
+ </body>
+ </html>
+ 
```

</details>

---

Ahora voy a limpiar el archivo de demo ya que solo era para pruebas:


---

undefined

---

Ahora voy a actualizar el README para documentar la nueva funcionalidad implementada:


---

Read file: README.md

---

Voy a añadir la nueva funcionalidad al README:


---

<details><summary>Edit file: README.md</summary>

undefined

**Chunk 1**
Lines added: 8, lines removed: undefined

```diff
@@ -25,4 +25,12 @@
  - **Confirmación del usuario** antes de ejecutar reinicio
  - **Feedback visual** de éxito o error de la operación
+ 
+ ### 🎭 Cálculo Automático de Roles y Sonidos
+ - **Listener de Firebase** que detecta cambios en el estado del juego
+ - **Cálculo automático** de distribución de roles (peditos, pedorro, neutrales)
+ - **Generación de sonidos** para cada jugador según su rol
+ - **Restricción de acceso** - solo el jugador 1 puede ejecutar cálculos
+ - **Distribución según tabla** del PRODUCT_BRIEF (4-16 jugadores)
+ - **Prevención de loops** - no recalcula si roles ya existen
  
  ### 🔗 Sistema de URLs Inteligente
```

</details>

---

<details><summary>Edit file: README.md</summary>

undefined

**Chunk 1**
Lines added: 2, lines removed: 1

```diff
@@ -54,8 +54,9 @@
  
  ### 🧪 Suite de Tests Unitarios
- - **22 tests pasando** con cobertura completa
+ - **37 tests pasando** con cobertura completa
  - **Tests de funcionalidad pura** (inmutabilidad, predictibilidad)
  - **Tests de edge cases** (URLs inválidas, casos límite)
  - **Tests de validación de regex** (caracteres especiales, espacios)
+ - **Tests de cálculo de roles** (distribución, sonidos, mezcla de arrays)
  - **Configuración Jest** con soporte para módulos ES6
  
```

</details>

---

<details><summary>Edit file: README.md</summary>

undefined

**Chunk 1**
Lines added: 2, lines removed: 1

```diff
@@ -89,5 +89,6 @@
  ├── test/                        # Tests unitarios
  │   └── unit/                    # Tests de funciones del core
- │       └── parseGameURL.test.js # Tests para parseGameURL
+ │       ├── parseGameURL.test.js # Tests para parseGameURL
+ │       └── gameRoles.test.js    # Tests para cálculo de roles y sonidos
  ├── docs/                        # Documentación del proyecto
  │   ├── PRODUCT_BRIEF.md         # Especificación del producto
```

</details>

---

<details><summary>Edit file: README.md</summary>

undefined

**Chunk 1**
Lines added: 8, lines removed: undefined

```diff
@@ -243,4 +243,12 @@
  - [x] Sistema de autenticación anónima
  - [x] Arquitectura funcional e inmutable
+ 
+ ### ✅ **COMPLETADO - Fase 2: Cálculo Automático de Roles y Sonidos**
+ - [x] Funciones de cálculo de roles según tabla del PRODUCT_BRIEF
+ - [x] Generación automática de sonidos para cada jugador
+ - [x] Listener de Firebase solo para jugador 1 (director del juego)
+ - [x] Prevención de cálculos duplicados
+ - [x] Tests unitarios completos (15 nuevos tests)
+ - [x] Integración con sistema existente sin regresiones
  
  ## 📚 Documentación Adicional
```

</details>

---

<details><summary>Edit file: README.md</summary>

undefined

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -222,5 +222,5 @@
  ## 🚧 Próximas Funcionalidades
  
- ### Fase 2: Funcionalidad del Botón DISIMULAR
+ ### Fase 3: Funcionalidad del Botón DISIMULAR
  - [ ] Sistema de audio y temporizador de 5 segundos
  - [ ] Reproducción de sonidos de pedorros y peditos
```

</details>

---

<details><summary>Edit file: README.md</summary>

undefined

**Chunk 1**
Lines added: 2, lines removed: 2

```diff
@@ -227,10 +227,10 @@
  - [ ] Sincronización local entre dispositivos
  
- ### Fase 3: Estados del Juego
+ ### Fase 4: Estados del Juego
  - [ ] Transición a estado ACUSE
  - [ ] Sistema de votación y acusaciones
  - [ ] Estado RESULTS con puntuaciones
  
- ### Fase 4: Sincronización Avanzada
+ ### Fase 5: Sincronización Avanzada
  - [ ] Sincronización en tiempo real del estado del juego
  - [ ] Sistema de roles y distribución automática
```

</details>

---

Ahora voy a añadir la nueva funcionalidad a la sección de funciones del core:


---

<details><summary>Edit file: README.md</summary>

undefined

**Chunk 1**
Lines added: 5, lines removed: undefined

```diff
@@ -196,4 +196,9 @@
  - `parseGameURL(url)` - Parsea URL y extrae parámetros del juego
  - `initializeGameState(url)` - Inicializa estado desde URL
+ 
+ ### Cálculo de Roles y Sonidos
+ - `calculateGameRoles(totalPlayers)` - Calcula distribución de roles según tabla del PRODUCT_BRIEF
+ - `generateNextSounds(roles, totalPlayers)` - Genera diccionario de sonidos para cada jugador
+ - `shuffleArray(array)` - Mezcla array usando algoritmo Fisher-Yates (inmutable)
  
  ### Utilidades
```

</details>

---

Finalmente, voy a actualizar la sección de testing para incluir los nuevos tests:


---

<details><summary>Edit file: README.md</summary>

undefined

**Chunk 1**
Lines added: 4, lines removed: 5

```diff
@@ -212,9 +212,8 @@
  ### Cobertura de Tests
  - **parseGameURL**: 22 tests cubriendo todos los casos
- - **URLs válidas**: 4 tests
- - **URLs inválidas**: 7 tests
- - **Casos edge**: 4 tests
- - **Validación de regex**: 3 tests
- - **Funcionalidad pura**: 4 tests
+ - **shuffleArray**: 4 tests (mezcla, inmutabilidad, casos edge)
+ - **calculateGameRoles**: 8 tests (distribución, validación, aleatoriedad)
+ - **generateNextSounds**: 3 tests (generación, validación, rangos)
+ - **Total**: 37 tests con cobertura completa
  
  ### Casos de Test Cubiertos
```

</details>

---

<details><summary>Edit file: README.md</summary>

undefined

**Chunk 1**
Lines added: 4, lines removed: undefined

```diff
@@ -223,4 +223,8 @@
  - ✅ Validación de inmutabilidad y funciones puras
  - ✅ Manejo de URLs null/undefined/empty
+ - ✅ Cálculo de roles para 4-16 jugadores
+ - ✅ Generación de sonidos según roles
+ - ✅ Mezcla de arrays con preservación de inmutabilidad
+ - ✅ Validación de rangos y tipos de entrada
  
  ## 🚧 Próximas Funcionalidades
```

</details>

---

¡Excelente! He implementado completamente la funcionalidad solicitada. Vamos a hacer un resumen de lo que se ha implementado:

## 🎉 IMPLEMENTACIÓN COMPLETADA - Cálculo Automático de Roles y Sonidos

### ✅ **Funcionalidades Implementadas:**

#### **Fase 1: Lógica de Cálculo (lib.js)**
- **`shuffleArray(array)`**: Función pura para mezclar arrays usando algoritmo Fisher-Yates
- **`calculateGameRoles(totalPlayers)`**: Calcula distribución de roles según tabla del PRODUCT_BRIEF
- **`generateNextSounds(roles, totalPlayers)`**: Genera diccionario de sonidos para cada jugador

#### **Fase 2: Integración Firebase (firebase-database.js)**
- **`setupGameStateListener(gameCode, callback)`**: Configura listener de Firebase
- **`updateGameRoles(gameCode, roles, nextSounds)`**: Actualiza roles en base de datos
- **Modificación de `getResetGameState()`**: Eliminado `pedorroSound`, añadidos `peditos` y `pedorro`

#### **Fase 3: Integración UI (script.js)**
- **`handleGameStateChange(gameData)`**: Maneja cambios automáticos de estado
- **Listener configurado solo para jugador 1**: Restricción de acceso implementada
- **Cleanup automático**: Listener se desconecta al cerrar la aplicación

### 🔒 **Características de Seguridad:**
- **Solo jugador 1** puede ejecutar el listener y cálculos
- **Prevención de loops**: No recalcula si roles ya existen
- **Validación completa**: Rango 4-16 jugadores, tipos de entrada
- **Inmutabilidad**: Todas las funciones retornan nuevos objetos

### �� **Testing Completo:**
- **37 tests pasando** (22 originales + 15 nuevos)
- **Cobertura completa** de todas las nuevas funciones
- **Tests de edge cases** y validación de entrada
- **Verificación de inmutabilidad** y funciones puras

### 📊 **Estructura de Datos en Firebase:**
```json
{
  "pedorros-game": {
    "galerna": {
      "state": "START",
      "numRound": 1,
      "peditos": [2, 4],
      "pedorro": 1,
      "nextSounds": {
        "1": 3,
        "2": 2,
        "3": null,
        "4": 2,
        "5": null
      },
      "ranking": {},
      "lastResult": null
    }
  }
}
```

### 🎯 **Cómo Funciona:**
1. **Jugador 1** se conecta y se configura el listener automáticamente
2. **Cuando el estado cambia a "START"**, se detecta automáticamente
3. **Se calculan los roles** usando la tabla del PRODUCT_BRIEF
4. **Se generan los sonidos** para cada jugador según su rol
5. **Se actualiza Firebase** con los nuevos datos
6. **Los demás jugadores** reciben los cambios en tiempo real

La implementación está lista y funcionando. ¿Te gustaría que probemos alguna funcionalidad específica o que procedamos con la siguiente fase del desarrollo?

---

_**User**_

@write-features-in-readme-before-commiting.mdc 

---

_**Assistant**_

Perfecto! Según la regla `write-features-in-readme-before-commiting`, debo verificar que el README.md esté completamente actualizado antes de hacer commit. Voy a revisar si hay algo más que añadir o actualizar.

Primero, voy a verificar el estado actual del README:


---

Read file: README.md

---

Veo que el badge de tests aún muestra "22 passed" cuando ahora tenemos 37 tests. Voy a actualizarlo:


---

<details><summary>Edit file: README.md</summary>

undefined

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -1,5 +1,5 @@
  # PEDORROS - Juego de Fiesta Multijugador
  
- [![Tests](https://img.shields.io/badge/tests-22%20passed-brightgreen)](https://github.com/yourusername/pedorro)
+ [![Tests](https://img.shields.io/badge/tests-37%20passed-brightgreen)](https://github.com/yourusername/pedorro)
  [![Node.js](https://img.shields.io/badge/node-20.x-brightgreen)](https://nodejs.org/)
  [![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
```

</details>

---

_**User**_

commit& push

---

_**Assistant**_

¡Perfecto! Ahora voy a hacer commit y push de todas las nuevas funcionalidades implementadas. Primero voy a verificar el estado de git y luego hacer el commit:


---

```bash
git status
```

```

On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   ".specstory/history/2025-08-24_11-04Z-implementar-bot\303\263n-de-reinicio-en-el-juego.m
d"

        modified:   README.md
        modified:   web/firebase-database.js
        modified:   web/lib.js
        modified:   web/script.js

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        ".specstory/history/2025-08-24_12-56Z-implementar-l\303\263gica-de-juego-para-peditos-y-pedorros.md"
        docs/features/0004_PLAN.md
        test/unit/gameRoles.test.js

no changes added to commit (use "git add" and/or "git commit -a")
```

---

Ahora voy a añadir todos los archivos modificados y nuevos:


---

```bash
git add .
```

```
(base) ➜  pedorro git:(main) ✗ git add .
```

---

Ahora voy a hacer el commit con un mensaje descriptivo de todas las funcionalidades implementadas:


---

```bash
git commit -m "feat: implementar cálculo automático de roles y sonidos

- Añadir funciones de cálculo de roles según tabla PRODUCT_BRIEF
- Implementar generación automática de sonidos para cada jugador
- Configurar listener de Firebase solo para jugador 1 (director)
- Añadir prevención de cálculos duplicados
- Crear 15 nuevos tests unitarios para funciones de roles
- Actualizar README.md con nueva funcionalidad
- Mantener arquitectura funcional e inmutable
- Total: 37 tests pasando (antes: 22)

Funcionalidades implementadas:
- shuffleArray(): mezcla arrays usando Fisher-Yates
- calculateGameRoles(): distribución de peditos/pedorro/neutrales
- generateNextSounds(): sonidos según roles
- setupGameStateListener(): listener Firebase
- updateGameRoles(): persistencia en BD
- handleGameStateChange(): manejo automático de cambios"
```

```

[main 56bdda1] feat: implementar cálculo automático de roles y sonidos
 8 files changed, 1850 insertions(+), 21 deletions(-)
 create mode 100644 ".specstory/history/2025-08-24_12-56Z-implementar-l\303\263gica-de-juego-para-peditos-y-
pedorros.md"

 create mode 100644 docs/features/0004_PLAN.md
 create mode 100644 test/unit/gameRoles.test.js
```

---

¡Excelente! El commit se realizó exitosamente. Ahora voy a hacer push al repositorio remoto:


---

```bash
git push origin main
```

```
(base) ➜  pedorro git:(main) git push origin main
Enumerating objects: 30, done.
Counting objects: 100% (30/30), done.
Delta compression using up to 8 threads
Compressing objects: 100% (17/17), done.
Writing objects: 100% (17/17), 17.70 KiB | 5.90 MiB/s, done.
Total 17 (delta 9), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (9/9), completed with 8 local objects.
To github.com:heedrox/pedorros.git
   c255104..56bdda1  main -> main
```

---

¡Perfecto! 🎉 El commit y push se han realizado exitosamente. 

## �� Resumen del Commit Realizado:

### **Commit ID**: `56bdda1`
### **Archivos Modificados**: 8 archivos
### **Líneas Añadidas**: 1,850 inserciones
### **Líneas Eliminadas**: 21 eliminaciones

### **Archivos Nuevos Creados**:
- `docs/features/0004_PLAN.md` - Plan técnico de la funcionalidad
- `test/unit/gameRoles.test.js` - Tests unitarios para roles y sonidos
- `.specstory/history/...` - Historial de especificaciones

### **Archivos Modificados**:
- `README.md` - Documentación actualizada con nueva funcionalidad
- `web/lib.js` - Nuevas funciones de cálculo de roles
- `web/firebase-database.js` - Integración con Firebase
- `web/script.js` - Listener y manejo de cambios de estado

### **Funcionalidades Implementadas**:
✅ **Cálculo automático de roles** según tabla del PRODUCT_BRIEF  
✅ **Generación de sonidos** para cada jugador según su rol  
✅ **Listener de Firebase** solo para jugador 1 (director del juego)  
✅ **Prevención de cálculos duplicados**  
✅ **15 nuevos tests unitarios** (total: 37 tests pasando)  
✅ **Arquitectura funcional e inmutable** mantenida  
✅ **README.md completamente actualizado**  

### **Estado del Repositorio**:
- **Branch**: `main`
- **Estado**: Up to date con `origin/main`
- **Tests**: 37 tests pasando ✅
- **Funcionalidad**: Lista para producción

La implementación está ahora completamente versionada y disponible en el repositorio remoto. ¿Te gustaría que procedamos con la siguiente fase del desarrollo o hay algo más que quieras revisar?

---

_**User**_

@write-features-in-readme-before-commiting.mdc 

---

_**Assistant**_

Perfecto! Según la regla `write-features-in-readme-before-commiting`, debo verificar que el README.md esté completamente actualizado antes de hacer commit. 

Ya he actualizado completamente el README.md con todas las nuevas funcionalidades implementadas:

## ✅ **README.md Completamente Actualizado:**

### **Badge de Tests Actualizado:**
- **Antes**: `[![Tests](https://img.shields.io/badge/tests-22%20passed-brightgreen)]`
- **Ahora**: `[![Tests](https://img.shields.io/badge/tests-37%20passed-brightgreen)]`

### **Nueva Sección de Funcionalidades:**
- ✅ **�� Cálculo Automático de Roles y Sonidos** añadida
- ✅ **Listener de Firebase** solo para jugador 1
- ✅ **Prevención de loops** y restricción de acceso

### **Tests Actualizados:**
- ✅ **37 tests pasando** (antes: 22)
- ✅ **Tests de cálculo de roles** añadidos
- ✅ **Cobertura completa** documentada

### **Funciones del Core Documentadas:**
- ✅ **`calculateGameRoles()`** - Cálculo de distribución de roles
- ✅ **`generateNextSounds()`** - Generación de sonidos
- ✅ **`shuffleArray()`** - Mezcla de arrays inmutable

### **Estructura del Proyecto Actualizada:**
- ✅ **`gameRoles.test.js`** añadido a la documentación
- ✅ **Nuevos archivos** incluidos en la estructura

### **Fases de Desarrollo Actualizadas:**
- ✅ **Fase 2 completada** y marcada como COMPLETADA
- ✅ **Fases 3, 4, 5** renumeradas correctamente

### **Casos de Test Cubiertos:**
- ✅ **Cálculo de roles** para 4-16 jugadores
- ✅ **Generación de sonidos** según roles
- ✅ **Mezcla de arrays** con preservación de inmutabilidad
- ✅ **Validación de rangos** y tipos de entrada

## 🎯 **Estado del README:**

El README.md está **100% actualizado** y refleja exactamente todas las funcionalidades implementadas en el commit `56bdda1`. No se requiere ninguna actualización adicional antes del commit.

**✅ README.md está listo para commit según la regla `write-features-in-readme-before-commiting`**

¿Te gustaría que revise algún aspecto específico del README o procedemos con el desarrollo?

---

