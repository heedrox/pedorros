<!-- Generated by SpecStory -->

# Implementar lógica de juego para peditos y pedorros (2025-08-24 12:56Z)

_**User**_

@plan-feature.md 

@read-readme-before-implementing-new-features.mdc 
Ahora quiero implementar que cuando el jugador haga listener de /pedorros-game/{codigo-juego}, y si el codigo-juego cambia, y el state = "START", entonces calcule:

- En base a la table que tienes en @PRODUCT_BRIEF.md sobre cantidad de peditos y pedorros y nada
- Meta en la BD, en el doc "codigo-juego" en el campo "peditos" un array de quienes seran los peditos, al azar. Tiene que ser un array de "cantidad de peditos" y todos distintos.
- Meta en la BD, en el doc "codigo-juego", en el campo "pedorro" un elemento de quien es el pedorro. Tiene que ser un numero, y no puede coincidir con los peditos".
    SUGERENCIA:  Una forma de hacer las dos funcionalidades anteriores es coger un array desde el 1 hasta num jugadores, hacer un shuffle, y coger "cantidad de peditos" primero, y esos son los peditos, coger otro elemento, ese es el pedorro, y el resto son "nada".
- Meta en la BD, en el doc "codigo-juego", en el campo "nextSounds", un diccionario con { 1: 1, 2: 1, 3: 1, .. }, siendo los keys del objeto el jugaodr (por tanto ira desde 1 hasta numjugadores) y el  valor el numero de sonido. El numero de sonido será: "null" si eres "nada". Para peditos será otro numero del 1 al 5 no null (el mismo para todos) y para pedorro será otro numero no null (puede ser el mismo de peditos o puede ser otro).

---

_**Assistant**_

Voy a leer el README y PRODUCT_BRIEF para entender mejor el contexto del proyecto antes de crear el plan técnico.


---

Read file: README.md

---

Ahora voy a examinar el código actual para entender mejor la implementación existente:


---

Read file: web/lib.js

---

Read file: web/script.js

---

Read file: web/firebase-database.js

---

Ahora voy a buscar si ya existe algún listener de Firebase en el código:


---

<details>
            <summary>Grep search for "onValue|onChildChanged|listener" • **3** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///Users/jordimarti/Development/pedorro/web/firebase-config.js` | L68 | `export const onAuthStateChangedListener = (callback) => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L23 | `onAuthStateChangedListener` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L216 | `// Event listener para el botón DISIMULAR` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L219 | `disimularButton.addEventListener('click', () => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L235 | `// Event listener para el botón REINICIAR` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L238 | `reiniciarButton.addEventListener('click', async () => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L289 | `// Configurar listener de cambios de autenticación` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L290 | `onAuthStateChangedListener((user) => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L307 | `// Event listener para el botón ACCEDER` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L310 | `accederButton.addEventListener('click', handleLogin);` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L317 | `// Event listener para cuando el DOM esté listo` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L318 | `document.addEventListener('DOMContentLoaded', initializeApp);` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L23 | `onAuthStateChangedListener` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L216 | `// Event listener para el botón DISIMULAR` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L219 | `disimularButton.addEventListener('click', () => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L235 | `// Event listener para el botón REINICIAR` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L238 | `reiniciarButton.addEventListener('click', async () => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L289 | `// Configurar listener de cambios de autenticación` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L290 | `onAuthStateChangedListener((user) => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L307 | `// Event listener para el botón ACCEDER` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L310 | `accederButton.addEventListener('click', handleLogin);` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L317 | `// Event listener para cuando el DOM esté listo` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L318 | `document.addEventListener('DOMContentLoaded', initializeApp);` |

</details>

---

Ahora voy a crear el plan técnico basado en la funcionalidad solicitada:


---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

Crear un nuevo plan técnico para implementar la funcionalidad de cálculo automático de roles y sonidos cuando cambia el código del juego

**Chunk 1**
Lines added: 174, lines removed: 1

```diff
@@ -1,1 +1,174 @@
- 
+ # PLAN TÉCNICO - Cálculo Automático de Roles y Sonidos
+ 
+ ## Descripción de la Funcionalidad
+ 
+ Implementar un listener de Firebase que detecte cambios en `/pedorros-game/{codigo-juego}` y, cuando el estado sea "START", calcule automáticamente:
+ 
+ 1. **Distribución de roles**: Asignar peditos, pedorro y neutrales según la tabla del PRODUCT_BRIEF
+ 2. **Sonidos asignados**: Generar diccionario `nextSounds` con sonidos para cada jugador
+ 3. **Persistencia en BD**: Guardar los resultados en Firebase Database
+ 
+ ## Archivos y Funciones a Modificar
+ 
+ ### Archivos Existentes a Modificar
+ 
+ #### `web/lib.js`
+ - **Nueva función**: `calculateGameRoles(totalPlayers)` - Calcula distribución de roles
+ - **Nueva función**: `generateNextSounds(roles, totalPlayers)` - Genera diccionario de sonidos
+ - **Nueva función**: `shuffleArray(array)` - Función de utilidad para mezclar arrays
+ 
+ #### `web/firebase-database.js`
+ - **Nueva función**: `setupGameStateListener(gameCode, callback)` - Configura listener de Firebase
+ - **Nueva función**: `updateGameRoles(gameCode, roles, nextSounds)` - Actualiza roles en BD
+ - **Modificar**: `getResetGameState()` - Añadir campos `peditos` y `pedorro`
+ 
+ #### `web/script.js`
+ - **Modificar**: `initializeApp()` - Configurar listener cuando se inicializa la app
+ - **Nueva función**: `handleGameStateChange(gameData)` - Maneja cambios en el estado del juego
+ 
+ ### Archivos a Crear
+ 
+ Ninguno - toda la funcionalidad se integra en archivos existentes.
+ 
+ ## Algoritmo de Implementación
+ 
+ ### Fase 1: Lógica de Cálculo de Roles (lib.js)
+ 
+ #### Función `calculateGameRoles(totalPlayers)`
+ 1. **Validar entrada**: Verificar que `totalPlayers` esté entre 4-16
+ 2. **Obtener distribución**: Usar tabla del PRODUCT_BRIEF para determinar cantidad de peditos
+ 3. **Generar array base**: Crear array `[1, 2, 3, ..., totalPlayers]`
+ 4. **Shuffle del array**: Mezclar aleatoriamente el array base
+ 5. **Extraer roles**:
+    - Tomar primeros `cantidadPeditos` elementos → `peditos`
+    - Tomar siguiente elemento → `pedorro`
+    - Resto → `neutrales` (no se almacenan, solo para lógica)
+ 6. **Retornar objeto**: `{ peditos: [...], pedorro: number }`
+ 
+ #### Función `generateNextSounds(roles, totalPlayers)`
+ 1. **Crear diccionario base**: `{ 1: null, 2: null, ..., totalPlayers: null }`
+ 2. **Asignar sonidos peditos**: Todos los peditos reciben el mismo número (1-5)
+ 3. **Asignar sonido pedorro**: Número único (1-5, puede coincidir con peditos)
+ 4. **Retornar diccionario**: `nextSounds` completo
+ 
+ #### Función `shuffleArray(array)`
+ 1. **Clonar array**: Evitar mutación del array original
+ 2. **Algoritmo Fisher-Yates**: Mezclar elementos aleatoriamente
+ 3. **Retornar array mezclado**: Nuevo array inmutable
+ 
+ ### Fase 2: Integración con Firebase (firebase-database.js)
+ 
+ #### Función `setupGameStateListener(gameCode, callback)`
+ 1. **Crear referencia**: `ref(database, 'pedorros-game/' + gameCode)`
+ 2. **Configurar listener**: `onValue(ref, callback)`
+ 3. **Manejar desconexión**: Retornar función de cleanup
+ 
+ #### Función `updateGameRoles(gameCode, roles, nextSounds)`
+ 1. **Validar datos**: Verificar estructura de roles y nextSounds
+ 2. **Actualizar BD**: Usar `update()` para modificar solo campos específicos
+ 3. **Manejar errores**: Retornar Promise con resultado de la operación
+ 
+ #### Modificación de `getResetGameState()`
+ 1. **Añadir campo `peditos`**: Array vacío por defecto
+ 2. **Añadir campo `pedorro`**: `null` por defecto
+ 3. **Mantener compatibilidad**: No romper funcionalidad existente
+ 
+ ### Fase 3: Integración en la UI (script.js)
+ 
+ #### Función `handleGameStateChange(gameData)`
+ 1. **Verificar estado**: Solo procesar si `state === "START"`
+ 2. **Verificar cambio de código**: Detectar si el código del juego cambió
+ 3. **Calcular roles**: Llamar a `calculateGameRoles()`
+ 4. **Generar sonidos**: Llamar a `generateNextSounds()`
+ 5. **Actualizar BD**: Llamar a `updateGameRoles()`
+ 
+ #### Modificación de `initializeApp()`
+ 1. **Configurar listener**: Llamar a `setupGameStateListener()`
+ 2. **Manejar cleanup**: Guardar referencia para limpieza posterior
+ 3. **Integrar con estado existente**: No interferir con funcionalidad actual
+ 
+ ## Detalles de Implementación
+ 
+ ### Estructura de Datos en Firebase
+ 
+ ```json
+ {
+   "pedorros-game": {
+     "galerna": {
+       "state": "START",
+       "numRound": 1,
+       "peditos": [2, 4],
+       "pedorro": 1,
+       "nextSounds": {
+         "1": 3,
+         "2": 2,
+         "3": null,
+         "4": 2,
+         "5": null
+       },
+       "ranking": {},
+       "lastResult": null,
+       "pedorroSound": null
+     }
+   }
+ }
+ ```
+ 
+ ### Lógica de Detección de Cambios
+ 
+ - **Listener activo**: Se configura una vez al inicializar la app
+ - **Detección de cambios**: Firebase notifica automáticamente cambios en el documento
+ - **Filtrado por estado**: Solo procesar cambios cuando `state === "START"`
+ - **Prevención de loops**: Verificar que los datos no sean los mismos que ya se calcularon
+ 
+ ### Manejo de Errores
+ 
+ - **Validación de entrada**: Verificar rangos válidos (4-16 jugadores)
+ - **Fallback de roles**: Si falla el cálculo, mantener estado anterior
+ - **Logging de errores**: Registrar errores para debugging
+ - **Recuperación**: Intentar recalcular en siguiente cambio de estado
+ 
+ ## Consideraciones Técnicas
+ 
+ ### Inmutabilidad
+ - **Funciones puras**: Todas las funciones de cálculo retornan nuevos objetos
+ - **Sin side effects**: No modificar arrays o objetos de entrada
+ - **Spread operator**: Usar para crear copias inmutables
+ 
+ ### Performance
+ - **Listener único**: Un solo listener por sesión de juego
+ - **Debouncing**: Evitar múltiples cálculos en cambios rápidos
+ - **Cleanup**: Limpiar listener al cerrar la app
+ 
+ ### Testing
+ - **Tests unitarios**: Para todas las funciones de cálculo
+ - **Tests de integración**: Para la lógica de Firebase
+ - **Mocks**: Simular Firebase para tests aislados
+ 
+ ## Dependencias
+ 
+ - **Firebase SDK**: Ya configurado en el proyecto
+ - **Funciones existentes**: Reutilizar lógica de validación y estado
+ - **Arquitectura actual**: Mantener separación lib.js vs script.js
+ 
+ ## Riesgos y Mitigaciones
+ 
+ ### Riesgo: Cálculo duplicado
+ - **Mitigación**: Verificar que los datos no sean idénticos antes de recalcular
+ 
+ ### Riesgo: Pérdida de sincronización
+ - **Mitigación**: Usar transacciones de Firebase para actualizaciones atómicas
+ 
+ ### Riesgo: Performance en cambios frecuentes
+ - **Mitigación**: Implementar debouncing y filtrado por estado
+ 
+ ## Criterios de Completado
+ 
+ - [ ] Función `calculateGameRoles()` implementada y testeada
+ - [ ] Función `generateNextSounds()` implementada y testeada
+ - [ ] Listener de Firebase configurado y funcionando
+ - [ ] Roles y sonidos se calculan automáticamente al cambiar código
+ - [ ] Datos se persisten correctamente en Firebase
+ - [ ] Tests unitarios pasando
+ - [ ] No regresiones en funcionalidad existente
+ 
```

</details>

---

Perfecto! He creado el plan técnico para implementar la funcionalidad solicitada. El plan está estructurado siguiendo la filosofía de **SMALL SAFE STEPS** y se divide en 3 fases lógicas:

## Resumen del Plan

**Funcionalidad**: Implementar un listener de Firebase que detecte cambios en el código del juego y calcule automáticamente la distribución de roles (peditos, pedorro, neutrales) y los sonidos correspondientes cuando el estado sea "START".

### Fases de Implementación:

1. **Fase 1 - Lógica de Cálculo** (`lib.js`): Funciones puras para calcular roles y generar sonidos
2. **Fase 2 - Integración Firebase** (`firebase-database.js`): Listener y funciones de actualización de BD
3. **Fase 3 - Integración UI** (`script.js`): Manejo de cambios de estado y configuración del listener

### Características Clave:

- **Inmutabilidad**: Todas las funciones retornan nuevos objetos sin side effects
- **Separación de responsabilidades**: Core logic en `lib.js`, Firebase en `firebase-database.js`, UI en `script.js`
- **Prevención de loops**: Verificación de datos antes de recalcular
- **Manejo de errores**: Fallbacks y logging para debugging
- **Performance**: Listener único con debouncing y cleanup

El plan incluye todos los detalles técnicos necesarios, desde la estructura de datos en Firebase hasta los algoritmos específicos para el cálculo de roles usando la tabla del PRODUCT_BRIEF. ¿Te gustaría que proceda con la implementación de alguna fase específica o tienes alguna pregunta sobre el plan?

---

_**User**_

Cuidado: esto del listener sobre este campo solo debe ser el jugador 1. El resto de jugadores deben ignorarlo.

---

_**Assistant**_

¡Excelente punto! Tienes razón, solo el jugador 1 (director del juego) debe ejecutar este cálculo automático. Voy a actualizar el plan técnico para reflejar esta restricción importante:


---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

undefined

**Chunk 1**
Lines added: 6, lines removed: 5

```diff
@@ -77,9 +77,10 @@
  
  #### Función `handleGameStateChange(gameData)`
- 1. **Verificar estado**: Solo procesar si `state === "START"`
- 2. **Verificar cambio de código**: Detectar si el código del juego cambió
- 3. **Calcular roles**: Llamar a `calculateGameRoles()`
- 4. **Generar sonidos**: Llamar a `generateNextSounds()`
- 5. **Actualizar BD**: Llamar a `updateGameRoles()`
+ 1. **Verificar jugador**: Solo procesar si es el jugador 1 (director del juego)
+ 2. **Verificar estado**: Solo procesar si `state === "START"`
+ 3. **Verificar cambio de código**: Detectar si el código del juego cambió
+ 4. **Calcular roles**: Llamar a `calculateGameRoles()`
+ 5. **Generar sonidos**: Llamar a `generateNextSounds()`
+ 6. **Actualizar BD**: Llamar a `updateGameRoles()`
  
  #### Modificación de `initializeApp()`
```

</details>

---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

undefined

**Chunk 1**
Lines added: 1, lines removed: undefined

```diff
@@ -120,4 +120,5 @@
  - **Listener activo**: Se configura una vez al inicializar la app
  - **Detección de cambios**: Firebase notifica automáticamente cambios en el documento
+ - **Filtrado por jugador**: Solo el jugador 1 procesa los cambios (director del juego)
  - **Filtrado por estado**: Solo procesar cambios cuando `state === "START"`
  - **Prevención de loops**: Verificar que los datos no sean los mismos que ya se calcularon
```

</details>

---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

undefined

**Chunk 1**
Lines added: 4, lines removed: 3

```diff
@@ -85,7 +85,8 @@
  
  #### Modificación de `initializeApp()`
- 1. **Configurar listener**: Llamar a `setupGameStateListener()`
- 2. **Manejar cleanup**: Guardar referencia para limpieza posterior
- 3. **Integrar con estado existente**: No interferir con funcionalidad actual
+ 1. **Verificar jugador**: Solo configurar listener si es el jugador 1
+ 2. **Configurar listener**: Llamar a `setupGameStateListener()` solo para jugador 1
+ 3. **Manejar cleanup**: Guardar referencia para limpieza posterior
+ 4. **Integrar con estado existente**: No interferir con funcionalidad actual
  
  ## Detalles de Implementación
```

</details>

---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

undefined

**Chunk 1**
Lines added: 2, lines removed: 1

```diff
@@ -140,7 +140,8 @@
  
  ### Performance
- - **Listener único**: Un solo listener por sesión de juego
+ - **Listener único**: Un solo listener por sesión de juego (solo jugador 1)
  - **Debouncing**: Evitar múltiples cálculos en cambios rápidos
  - **Cleanup**: Limpiar listener al cerrar la app
+ - **Filtrado eficiente**: Solo jugador 1 procesa cambios, resto ignora
  
  ### Testing
```

</details>

---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

undefined

**Chunk 1**
Lines added: 3, lines removed: undefined

```diff
@@ -166,4 +166,7 @@
  ### Riesgo: Performance en cambios frecuentes
  - **Mitigación**: Implementar debouncing y filtrado por estado
+ 
+ ### Riesgo: Múltiples jugadores ejecutando cálculo
+ - **Mitigación**: Restricción estricta - solo jugador 1 puede ejecutar el listener
  
  ## Criterios de Completado
```

</details>

---

Perfecto! He actualizado el plan técnico para incluir la restricción importante de que **solo el jugador 1 (director del juego) debe ejecutar el listener y los cálculos automáticos**.

## Cambios Realizados en el Plan:

### 1. **Verificación de Jugador en `handleGameStateChange()`**
- Añadido paso 1: "Verificar jugador: Solo procesar si es el jugador 1 (director del juego)"

### 2. **Configuración del Listener Solo para Jugador 1**
- Modificado `initializeApp()` para verificar que solo el jugador 1 configure el listener
- Los demás jugadores no tendrán listener activo

### 3. **Filtrado por Jugador en la Lógica de Detección**
- Añadido "Filtrado por jugador: Solo el jugador 1 procesa los cambios (director del juego)"

### 4. **Performance Optimizada**
- Añadido "Filtrado eficiente: Solo jugador 1 procesa cambios, resto ignora"

### 5. **Nuevo Riesgo Identificado y Mitigado**
- Riesgo: "Múltiples jugadores ejecutando cálculo"
- Mitigación: "Restricción estricta - solo jugador 1 puede ejecutar el listener"

Esta restricción es crucial porque:
- **Evita cálculos duplicados** por múltiples dispositivos
- **Mantiene la autoridad del director** del juego (jugador 1)
- **Mejora la performance** al reducir procesamiento innecesario
- **Previene conflictos** en la base de datos

¿Te parece correcta esta restricción? ¿Hay algún otro aspecto del plan que quieras que ajuste?

---

_**User**_

ya creo que no se necesita el campo "pedorroSound", ya que lo hemos cambiado por "peditos" y "pedorro".

---

_**Assistant**_

Tienes razón! El campo `pedorroSound` ya no es necesario con la nueva estructura. Voy a actualizar el plan para eliminar esa referencia:


---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

undefined

**Chunk 1**
Lines added: 1, lines removed: 2

```diff
@@ -110,6 +110,5 @@
        },
        "ranking": {},
-       "lastResult": null,
-       "pedorroSound": null
+       "lastResult": null
      }
    }
```

</details>

---

<details><summary>Edit file: docs/features/0004_PLAN.md</summary>

undefined

**Chunk 1**
Lines added: 2, lines removed: 1

```diff
@@ -72,5 +72,6 @@
  1. **Añadir campo `peditos`**: Array vacío por defecto
  2. **Añadir campo `pedorro`**: `null` por defecto
- 3. **Mantener compatibilidad**: No romper funcionalidad existente
+ 3. **Eliminar campo `pedorroSound`**: Ya no necesario con nueva estructura
+ 4. **Mantener compatibilidad**: No romper funcionalidad existente
  
  ### Fase 3: Integración en la UI (script.js)
```

</details>

---

Perfecto! He actualizado el plan para eliminar el campo `pedorroSound` que ya no es necesario. 

## Cambios Realizados:

### 1. **Estructura de Datos en Firebase Actualizada**
- Eliminado el campo `"pedorroSound": null` del ejemplo JSON
- La estructura ahora es más limpia y coherente

### 2. **Modificación de `getResetGameState()`**
- Añadido paso 3: "Eliminar campo `pedorroSound`: Ya no necesario con nueva estructura"
- El campo se elimina completamente de la función

## Estructura Final de Datos:

La nueva estructura es más lógica y eficiente:
- **`peditos`**: Array con los números de jugadores que son peditos
- **`pedorro`**: Número del jugador que es el pedorro
- **`nextSounds`**: Diccionario completo con todos los sonidos (incluyendo el del pedorro)

Esto elimina la redundancia y hace que la información esté centralizada en `nextSounds`, donde el sonido del pedorro se puede obtener simplemente accediendo a `nextSounds[pedorro]`.

¿Te parece correcta esta simplificación? ¿Hay algún otro campo o aspecto que quieras que revise?

---

_**User**_

Ok, vamos a implementar!

---

_**Assistant**_

¡Perfecto! Vamos a implementar la funcionalidad paso a paso. Empezaré por la **Fase 1** implementando las funciones de cálculo en `lib.js`.

## Fase 1: Lógica de Cálculo de Roles (lib.js)

Primero voy a añadir las nuevas funciones al archivo `lib.js`:


---

Read file: web/lib.js

---

Ahora voy a añadir las nuevas funciones de cálculo al final del archivo:


---

<details><summary>Edit file: web/lib.js</summary>

Añadir las nuevas funciones de cálculo de roles y sonidos al final del archivo, después de getResetGameState

**Chunk 1**
Lines added: 93, lines removed: 2

```diff
@@ -141,5 +141,96 @@
      state: "START",
      nextSounds: {},
-     pedorroSound: null
- });
+     peditos: [],
+     pedorro: null
+ });
+ 
+ // Función pura para mezclar un array (algoritmo Fisher-Yates)
+ export const shuffleArray = (array) => {
+     if (!Array.isArray(array)) {
+         return [];
+     }
+     
+     const shuffled = [...array]; // Clonar array para mantener inmutabilidad
+     
+     for (let i = shuffled.length - 1; i > 0; i--) {
+         const j = Math.floor(Math.random() * (i + 1));
+         [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
+     }
+     
+     return shuffled;
+ };
+ 
+ // Función pura para calcular la distribución de roles según el número de jugadores
+ export const calculateGameRoles = (totalPlayers) => {
+     // Validar rango de jugadores (4-16 según PRODUCT_BRIEF)
+     if (totalPlayers < 4 || totalPlayers > 16) {
+         return {
+             success: false,
+             error: 'Número de jugadores debe estar entre 4 y 16',
+             peditos: [],
+             pedorro: null
+         };
+     }
+     
+     // Tabla de distribución según PRODUCT_BRIEF
+     const roleDistribution = {
+         4: { peditos: 2, pedorros: 1, neutrales: 1 },
+         5: { peditos: 2, pedorros: 1, neutrales: 2 },
+         6: { peditos: 3, pedorros: 1, neutrales: 2 },
+         7: { peditos: 4, pedorros: 1, neutrales: 2 },
+         8: { peditos: 4, pedorros: 1, neutrales: 3 },
+         9: { peditos: 5, pedorros: 1, neutrales: 3 },
+         10: { peditos: 6, pedorros: 1, neutrales: 3 },
+         11: { peditos: 6, pedorros: 1, neutrales: 4 },
+         12: { peditos: 7, pedorros: 1, neutrales: 4 },
+         13: { peditos: 8, pedorros: 1, neutrales: 4 },
+         14: { peditos: 8, pedorros: 1, neutrales: 5 },
+         15: { peditos: 9, pedorros: 1, neutrales: 5 },
+         16: { peditos: 10, pedorros: 1, neutrales: 5 }
+     };
+     
+     const distribution = roleDistribution[totalPlayers];
+     
+     // Generar array base [1, 2, 3, ..., totalPlayers]
+     const baseArray = Array.from({ length: totalPlayers }, (_, i) => i + 1);
+     
+     // Mezclar el array
+     const shuffledArray = shuffleArray(baseArray);
+     
+     // Extraer roles
+     const peditos = shuffledArray.slice(0, distribution.peditos);
+     const pedorro = shuffledArray[distribution.peditos];
+     
+     return {
+         success: true,
+         peditos,
+         pedorro,
+         totalPlayers
+     };
+ };
+ 
+ // Función pura para generar el diccionario de sonidos para cada jugador
+ export const generateNextSounds = (roles, totalPlayers) => {
+     if (!roles || !roles.success || !roles.peditos || !roles.pedorro) {
+         return {};
+     }
+     
+     // Crear diccionario base con null para todos
+     const nextSounds = {};
+     for (let i = 1; i <= totalPlayers; i++) {
+         nextSounds[i] = null;
+     }
+     
+     // Asignar sonido para peditos (mismo número del 1-5)
+     const peditoSound = Math.floor(Math.random() * 5) + 1;
+     roles.peditos.forEach(playerNum => {
+         nextSounds[playerNum] = peditoSound;
+     });
+     
+     // Asignar sonido para pedorro (número del 1-5, puede coincidir)
+     const pedorroSound = Math.floor(Math.random() * 5) + 1;
+     nextSounds[roles.pedorro] = pedorroSound;
+     
+     return nextSounds;
+ };
  
```

</details>

---

¡Excelente! Ahora vamos con la **Fase 2**: Integración con Firebase. Voy a modificar `firebase-database.js`:


---

<details><summary>Edit file: web/firebase-database.js</summary>

Añadir las nuevas funciones de listener y actualización de roles, y modificar getResetGameState para eliminar pedorroSound

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -5,5 +5,5 @@
  
  import { database } from './firebase-config.js';
- import { ref, set } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
+ import { ref, set, onValue, update, off } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
  
  /**
```

**Chunk 2**
Lines added: 2, lines removed: 1

```diff
@@ -25,5 +25,6 @@
      state: "START",
      nextSounds: {},
-     pedorroSound: null
+     peditos: [],
+     pedorro: null
  });
  
```

**Chunk 3**
Lines added: 79, lines removed: undefined

```diff
@@ -59,3 +60,82 @@
      }
  };
+ 
+ /**
+  * Configura un listener para cambios en el estado del juego
+  * @param {string} gameCode - Código del juego (ej: "galerna")
+  * @param {Function} callback - Función a ejecutar cuando cambie el estado
+  * @returns {Function} Función de cleanup para desconectar el listener
+  */
+ export const setupGameStateListener = (gameCode, callback) => {
+     try {
+         if (!gameCode || typeof gameCode !== 'string') {
+             throw new Error('Código de juego inválido');
+         }
+ 
+         const gameRef = ref(database, `pedorros-game/${gameCode}`);
+         
+         // Configurar listener
+         onValue(gameRef, (snapshot) => {
+             const gameData = snapshot.val();
+             if (gameData && callback) {
+                 callback(gameData);
+             }
+         });
+         
+         // Retornar función de cleanup
+         return () => {
+             off(gameRef);
+         };
+     } catch (error) {
+         console.error('Error al configurar listener del juego:', error);
+         return () => {}; // Función de cleanup vacía en caso de error
+     }
+ };
+ 
+ /**
+  * Actualiza los roles y sonidos del juego en Firebase Database
+  * @param {string} gameCode - Código del juego
+  * @param {Object} roles - Objeto con peditos y pedorro
+  * @param {Object} nextSounds - Diccionario de sonidos por jugador
+  * @returns {Promise<Object>} Resultado de la operación
+  */
+ export const updateGameRoles = async (gameCode, roles, nextSounds) => {
+     try {
+         if (!gameCode || typeof gameCode !== 'string') {
+             throw new Error('Código de juego inválido');
+         }
+ 
+         if (!roles || !roles.success || !roles.peditos || !roles.pedorro) {
+             throw new Error('Estructura de roles inválida');
+         }
+ 
+         if (!nextSounds || typeof nextSounds !== 'object') {
+             throw new Error('Estructura de sonidos inválida');
+         }
+ 
+         const gameRef = ref(database, `pedorros-game/${gameCode}`);
+         
+         // Actualizar solo los campos específicos
+         await update(gameRef, {
+             peditos: roles.peditos,
+             pedorro: roles.pedorro,
+             nextSounds: nextSounds
+         });
+         
+         return {
+             success: true,
+             message: 'Roles y sonidos actualizados exitosamente',
+             gameCode,
+             roles,
+             nextSounds
+         };
+     } catch (error) {
+         console.error('Error al actualizar roles del juego:', error);
+         return {
+             success: false,
+             error: error.message,
+             gameCode
+         };
+     }
+ };
  
```

</details>

---

Ahora vamos con la **Fase 3**: Integración en la UI. Voy a modificar `script.js`:


---

Read file: web/script.js

---

Voy a actualizar los imports y añadir las nuevas funciones:


---

<details><summary>Edit file: web/script.js</summary>

Actualizar los imports para incluir las nuevas funciones de cálculo y Firebase, y añadir las nuevas funciones de manejo de cambios de estado

**Chunk 1**
Lines added: 2, lines removed: undefined

```diff
@@ -15,4 +15,6 @@
      isPlayerOne,
      getResetGameState,
+     calculateGameRoles,
+     generateNextSounds,
      AUTH_STATES
  } from './lib.js';
```

**Chunk 2**
Lines added: 6, lines removed: 1

```diff
@@ -25,9 +27,14 @@
  
  import {
-     resetGameState
+     resetGameState,
+     setupGameStateListener,
+     updateGameRoles
  } from './firebase-database.js';
  
  // Estado de autenticación (separado del estado del juego)
  let authState = AUTH_STATES.UNAUTHENTICATED;
+ 
+ // Variable para almacenar la función de cleanup del listener
+ let gameStateListenerCleanup = null;
  
  // Función pura para renderizar la pantalla según el estado de autenticación
```

</details>

---

Ahora voy a añadir la función para manejar cambios en el estado del juego:


---

Read file: web/script.js

---

Ahora voy a añadir la función de manejo de cambios de estado del juego antes de `initializeApp`:


---

<details><summary>Edit file: web/script.js</summary>

Añadir la función handleGameStateChange antes de initializeApp para manejar los cambios automáticos de roles y sonidos

**Chunk 1**
Lines added: 54, lines removed: undefined

```diff
@@ -289,4 +289,58 @@
      };
  };
+ 
+ // Función para manejar cambios en el estado del juego (solo jugador 1)
+ const handleGameStateChange = async (gameData) => {
+     // Solo procesar si es el jugador 1 (director del juego)
+     if (!gameState || !isPlayerOne(gameState)) {
+         return;
+     }
+     
+     // Solo procesar si el estado es "START"
+     if (gameData.state !== "START") {
+         return;
+     }
+     
+     // Verificar si ya existen roles calculados para evitar recalcular
+     if (gameData.peditos && gameData.peditos.length > 0 && gameData.pedorro) {
+         console.log('Roles ya calculados, saltando cálculo automático');
+         return;
+     }
+     
+     console.log('Estado START detectado, calculando roles automáticamente...');
+     
+     try {
+         // Calcular distribución de roles
+         const roles = calculateGameRoles(gameState.totalPlayers);
+         
+         if (!roles.success) {
+             console.error('Error al calcular roles:', roles.error);
+             return;
+         }
+         
+         // Generar sonidos para cada jugador
+         const nextSounds = generateNextSounds(roles, gameState.totalPlayers);
+         
+         if (Object.keys(nextSounds).length === 0) {
+             console.error('Error al generar sonidos');
+             return;
+         }
+         
+         console.log('Roles calculados:', roles);
+         console.log('Sonidos generados:', nextSounds);
+         
+         // Actualizar en Firebase Database
+         const result = await updateGameRoles(gameState.gameCode, roles, nextSounds);
+         
+         if (result.success) {
+             console.log('Roles y sonidos actualizados exitosamente en Firebase');
+         } else {
+             console.error('Error al actualizar roles en Firebase:', result.error);
+         }
+         
+     } catch (error) {
+         console.error('Error inesperado al calcular roles:', error);
+     }
+ };
  
  // Función principal de inicialización de la aplicación
```

</details>

---

Ahora necesito modificar la función `initializeGame` para configurar el listener solo para el jugador 1. Voy a buscar esa función:


---

<details>
            <summary>Grep search for "const initializeGame" • **4** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L195 | `const initializeGame = () => {` |
| `file:///Users/jordimarti/Development/pedorro/web/lib.js` | L59 | `export const initializeGameState = (url) => {` |
| `file:///Users/jordimarti/Development/pedorro/web/script.js` | L195 | `const initializeGame = () => {` |
| `file:///Users/jordimarti/Development/pedorro/web/lib.js` | L59 | `export const initializeGameState = (url) => {` |

</details>

---

Read file: web/script.js

---

Ahora voy a modificar la función `initializeGame` para configurar el listener solo para el jugador 1:


---



---



---

